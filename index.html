<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decked Out - Enhanced Flashcards</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Poppins", "Arial", sans-serif;
}

:root {
  --primary: #6366f1;
  --primary-dark: #4f46e5;
  --secondary: #f43f5e;
  --secondary-dark: #e11d48;
  --accent: #8b5cf6;
  --accent-dark: #7c3aed;
  --success: #10b981;
  --warning: #f59e0b;
  --danger: #ef4444;
  --bg-dark: #0f172a;
  --bg-card: #1e293b;
  --bg-secondary: #334155;
  --text-light: #f8fafc;
  --text-dim: #94a3b8;
  --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
  --card-radius: 16px;
  --btn-radius: 12px;
  --input-radius: 10px;
}

body {
  background-color: var(--bg-dark);
  color: var(--text-light);
  display: flex;
  justify-content: center;
  min-height: 100vh;
  padding: 20px;
  font-size: 16px;
}

.app-container {
  width: 90%;
  max-width: 500px;
  margin: 40px auto;
  position: relative;
  display: flex;
  flex-direction: column;
}

h1 {
  margin-bottom: 30px;
  font-size: 2.5rem;
  font-weight: 700;
  background: linear-gradient(to right, var(--primary), var(--accent));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-align: center;
}

h2 {
  margin: 30px 0 15px;
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text-light);
  text-align: center;
}

/* Study Stats Bar */
.study-stats {
  display: flex;
  justify-content: space-around;
  background: var(--bg-card);
  border-radius: var(--card-radius);
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: var(--shadow);
}

.stat-item {
  text-align: center;
}

.stat-number {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--primary);
}

.stat-label {
  font-size: 0.8rem;
  color: var(--text-dim);
  text-transform: uppercase;
}

/* Carousel and flashcard styling */
.carousel {
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  width: 100%;
  height: 320px;
  perspective: 1200px;
  margin: 40px 0;
}

.flashcard {
  width: 320px;
  height: 260px;
  position: absolute;
  transform-style: preserve-3d;
  transition: all 0.7s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  border-radius: var(--card-radius);
  box-shadow: var(--shadow);
  cursor: pointer;
}

.left {
  background-color: rgba(255, 255, 255, 0.05);
  opacity: 0.15;
  transform: translateX(-200px) rotateY(-15deg) scale(0.85);
  filter: blur(2px);
}

.main {
  background: linear-gradient(135deg, var(--primary), var(--accent));
  z-index: 10;
}

.right {
  background-color: rgba(255, 255, 255, 0.05);
  opacity: 0.15;
  transform: translateX(200px) rotateY(15deg) scale(0.85);
  filter: blur(2px);
}

.card-face {
  width: 100%;
  height: 100%;
  position: absolute;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  border-radius: var(--card-radius);
  font-size: 20px;
  font-weight: 600;
  backface-visibility: hidden;
  padding: 20px;
  text-align: center;
  overflow: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.front {
  background: linear-gradient(135deg, var(--primary), var(--accent));
}

.back {
  background: linear-gradient(135deg, var(--secondary), var(--accent));
  transform: rotateY(180deg);
}

.main.flipped {
  transform: rotateY(180deg);
}

/* Card metadata */
.card-metadata {
  position: absolute;
  top: 10px;
  left: 10px;
  right: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12px;
  opacity: 0.8;
}

.card-tags {
  display: flex;
  gap: 5px;
  flex-wrap: wrap;
}

.tag {
  background: rgba(255, 255, 255, 0.2);
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 10px;
}

.card-interval {
  background: rgba(255, 255, 255, 0.2);
  padding: 2px 8px;
  border-radius: 6px;
}

/* Enhanced Confidence Buttons */
.confidence-buttons {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin: 20px 0;
  flex-wrap: wrap;
}

.confidence-btn {
  padding: 12px 20px;
  border-radius: 50px;
  font-weight: 600;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 8px;
  border: none;
  color: white;
  cursor: pointer;
  min-width: 100px;
  justify-content: center;
}

.confidence-btn i {
  font-size: 16px;
}

.confidence-btn.again {
  background-color: var(--danger);
}

.confidence-btn.hard {
  background-color: var(--warning);
}

.confidence-btn.good {
  background-color: var(--success);
}

.confidence-btn.easy {
  background-color: var(--primary);
}

.confidence-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.confidence-btn .interval-time {
  font-size: 12px;
  opacity: 0.9;
}

/* Button styling */
button {
  padding: 12px 20px;
  border: none;
  border-radius: var(--btn-radius);
  background-color: var(--primary);
  color: white;
  font-size: 16px;
  font-weight: 500;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

button:hover {
  background-color: var(--primary-dark);
  transform: translateY(-2px);
  box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.2);
}

button:active {
  transform: translateY(0);
}

.navigation-buttons {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin: 15px 0;
}

.prev-btn {
  background-color: var(--accent);
}

.prev-btn:hover {
  background-color: var(--accent-dark);
}

.clear-btn {
  background-color: var(--secondary);
}

.clear-btn:hover {
  background-color: var(--secondary-dark);
}

/* Form styling */
form {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin-top: 20px;
  width: 100%;
}

input, textarea, select {
  padding: 14px;
  border-radius: var(--input-radius);
  border: 1px solid rgba(255, 255, 255, 0.1);
  background: var(--bg-card);
  color: var(--text-light);
  font-size: 16px;
  width: 100%;
  transition: all 0.3s ease;
  resize: vertical;
  font-family: "Poppins", "Arial", sans-serif;
  min-height: 50px;
}

textarea {
  min-height: 80px;
}

input:focus, textarea:focus, select:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);
}

input::placeholder, textarea::placeholder {
  color: var(--text-dim);
}

/* Card Type Selector */
.card-type-selector {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}

.card-type-btn {
  flex: 1;
  padding: 8px 12px;
  background: var(--bg-secondary);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  color: var(--text-dim);
  font-size: 14px;
  transition: all 0.3s ease;
}

.card-type-btn.active {
  background: var(--primary);
  color: white;
  border-color: var(--primary);
}

/* Enhanced form fields */
.form-row {
  display: flex;
  gap: 15px;
}

.form-row > * {
  flex: 1;
}

.tags-input {
  position: relative;
}

.tag-suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--bg-card);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  max-height: 150px;
  overflow-y: auto;
  z-index: 10;
  display: none;
}

.tag-suggestion {
  padding: 8px 12px;
  cursor: pointer;
  transition: background 0.2s;
}

.tag-suggestion:hover {
  background: var(--bg-secondary);
}

/* Presets dropdown styling */
.presets-container {
  position: absolute;
  top: -30px;
  right: 0;
  z-index: 20;
}

.dropdown-btn {
  background-color: var(--accent);
  padding: 10px 15px;
  border-radius: var(--btn-radius);
  font-size: 15px;
}

.dropdown-btn:hover {
  background-color: var(--accent-dark);
}

.preset-dropdown-content {
  display: none;
  position: absolute;
  right: 0;
  margin-top: 10px;
  background-color: var(--bg-card);
  min-width: 250px;
  padding: 15px;
  z-index: 10;
  box-shadow: var(--shadow);
  border-radius: var(--btn-radius);
  max-height: 400px;
  overflow-y: auto;
}

.preset-dropdown-content button {
  display: block;
  width: 100%;
  margin-bottom: 10px;
  text-align: left;
}

.preset-dropdown-content ul {
  list-style-type: none;
  padding: 0;
  margin-top: 15px;
}

.preset-dropdown-content ul li {
  padding: 12px;
  background-color: rgba(99, 102, 241, 0.2);
  color: var(--text-light);
  border-radius: 8px;
  cursor: pointer;
  margin-bottom: 8px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.preset-dropdown-content ul li:hover {
  background-color: rgba(99, 102, 241, 0.3);
}

.preset-info {
  display: flex;
  flex-direction: column;
  flex: 1;
}

.preset-name {
  font-weight: 600;
  margin-bottom: 2px;
}

.preset-meta {
  font-size: 12px;
  color: var(--text-dim);
}

.delete-btn {
  background-color: var(--secondary);
  color: white;
  font-size: 12px;
  padding: 5px 8px;
  border-radius: 5px;
  margin-left: 8px;
}

.delete-btn:hover {
  background-color: var(--secondary-dark);
}

/* Modal Styles */
.modal {
  display: none;
  position: fixed;
  z-index: 100;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(5px);
}

.modal-content {
  background-color: var(--bg-card);
  margin: 5% auto;
  padding: 25px;
  border: 1px solid rgba(255, 255, 255, 0.05);
  width: 90%;
  max-width: 700px;
  border-radius: var(--card-radius);
  box-shadow: var(--shadow);
  animation: fadeIn 0.3s;
  max-height: 80vh;
  overflow-y: auto;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}

.close {
  color: var(--text-dim);
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  transition: color 0.3s;
}

.close:hover, .close:focus {
  color: var(--text-light);
}

/* Statistics Modal */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 20px;
  margin: 20px 0;
}

.stat-card {
  background: var(--bg-secondary);
  padding: 20px;
  border-radius: var(--card-radius);
  text-align: center;
}

.stat-card h3 {
  color: var(--primary);
  margin-bottom: 10px;
}

.stat-card .big-number {
  font-size: 2rem;
  font-weight: 700;
  color: var(--text-light);
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: var(--bg-dark);
  border-radius: 4px;
  margin: 10px 0;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(to right, var(--primary), var(--accent));
  transition: width 0.3s ease;
}

/* Deck Editor Styles */
.deck-editor-item {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 20px;
  padding: 15px;
  background: var(--bg-secondary);
  border-radius: 8px;
}

.deck-editor-fields {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.deck-editor-meta {
  display: flex;
  gap: 10px;
  align-items: center;
  margin-top: 10px;
}

.deck-editor-meta input, .deck-editor-meta select {
  flex: 1;
  min-height: 40px;
}

.deck-editor-item button {
  background-color: var(--secondary);
  padding: 8px 12px;
  border-radius: 8px;
  align-self: flex-start;
}

/* Study Mode Toggle */
.study-mode-toggle {
  display: flex;
  background: var(--bg-card);
  border-radius: 25px;
  padding: 4px;
  margin: 20px auto;
  width: fit-content;
}

.mode-btn {
  padding: 8px 16px;
  border-radius: 20px;
  background: transparent;
  color: var(--text-dim);
  font-size: 14px;
  transition: all 0.3s ease;
}

.mode-btn.active {
  background: var(--primary);
  color: white;
}

/* Flashcard counter and info */
.card-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 10px 0;
  padding: 10px;
  background: var(--bg-card);
  border-radius: 8px;
  font-size: 14px;
  color: var(--text-dim);
}

.due-status {
  display: flex;
  gap: 15px;
}

.due-item {
  display: flex;
  align-items: center;
  gap: 5px;
}

.due-new { color: var(--primary); }
.due-learning { color: var(--warning); }
.due-review { color: var(--success); }

/* Responsive design */
@media (max-width: 768px) {
  .carousel { height: 280px; }
  .flashcard { width: 280px; height: 220px; }
  .card-face { font-size: 18px; padding: 15px; }
  .confidence-buttons { flex-direction: column; }
  .confidence-btn { min-width: auto; }
  .stats-grid { grid-template-columns: 1fr; }
  .form-row { flex-direction: column; }
}

@media (max-width: 480px) {
  .carousel { height: 240px; }
  .flashcard { width: 250px; height: 200px; }
  .card-face { font-size: 16px; padding: 12px; }
  .study-stats { flex-direction: column; gap: 10px; }
  .modal-content { padding: 15px; margin: 10% auto; }
}

/* Animations */
.pulse {
  animation: pulse 0.3s ease;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

.shake {
  animation: shake 0.5s ease;
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}
/* Session Timer Styles */
.session-options {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 20px 0;
}

.session-option {
    background: var(--bg-secondary);
    padding: 20px;
    border-radius: var(--card-radius);
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
}

.session-option:hover {
    transform: translateY(-5px);
    box-shadow: var(--shadow);
}

.session-option i {
    font-size: 2rem;
    margin-bottom: 10px;
    color: var(--primary);
}

.session-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding: 15px;
    background: var(--bg-secondary);
    border-radius: var(--card-radius);
}

#sessionTimer {
    font-size: 1.8rem;
    font-weight: bold;
    color: var(--primary);
}
/* Quizlet Import Styles */
.import-options {
    display: grid;
    grid-template-columns: 1fr;
    gap: 20px;
}

.import-option {
    background: var(--bg-secondary);
    padding: 20px;
    border-radius: var(--card-radius);
}

.import-option textarea, .import-option input {
    width: 100%;
    margin: 10px 0;
}

#importPreviewList {
    max-height: 300px;
    overflow-y: auto;
    margin: 15px 0;
}

.preview-card {
    padding: 10px;
    margin-bottom: 10px;
    background: var(--bg-card);
    border-radius: 8px;
    border-left: 4px solid var(--primary);
}
/* Hardest Cards Styles */
.btn-hardest-mode {
    padding: 12px 24px;
    border-radius: 25px;
    font-weight: 600;
    background-color: #e74c3c;
    color: white;
    border: none;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 6px rgba(231, 76, 60, 0.3);
}

.btn-hardest-mode:hover {
    background-color: #c0392b;
    transform: translateY(-2px);
    box-shadow: 0 6px 8px rgba(231, 76, 60, 0.4);
}

/* Anki Import Styles */
.import-option {
    background: var(--bg-secondary);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 15px;
}

.import-option h3 {
    margin-top: 0;
    color: var(--primary);
}

.import-option input[type="file"] {
    width: 100%;
    margin: 10px 0;
    padding: 8px;
    border-radius: 4px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    background: var(--bg-card);
    color: var(--text-light);
}
/* Image Upload Styles */
.image-upload-container {
    margin: 15px 0;
    position: relative;
}

.image-preview {
    width: 100%;
    max-height: 200px;
    margin: 10px 0;
    border-radius: 8px;
    overflow: hidden;
    display: none;
}

.image-preview img {
    width: 100%;
    height: auto;
    object-fit: contain;
}

.remove-image {
    position: absolute;
    top: 5px;
    right: 5px;
    background: var(--danger);
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    cursor: pointer;
    display: none;
}

.upload-btn {
    background: var(--bg-secondary);
    border: 2px dashed rgba(255, 255, 255, 0.2);
    padding: 20px;
    text-align: center;
    border-radius: var(--card-radius);
    cursor: pointer;
    transition: all 0.3s ease;
}

.upload-btn:hover {
    border-color: var(--primary);
    background: rgba(99, 102, 241, 0.1);
}

.upload-btn i {
    font-size: 24px;
    margin-bottom: 8px;
    color: var(--primary);
}
.mc-options { margin-top: 8px; padding-left: 18px; }
.mc-options li { margin: 2px 0; }
/* Search and Filter Styles */
.search-filter-bar {
    background: var(--bg-card);
    border-radius: var(--card-radius);
    padding: 15px;
    margin-bottom: 20px;
    box-shadow: var(--shadow);
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    align-items: center;
}

.search-container {
    position: relative;
    flex: 1;
    min-width: 250px;
}

.search-container i {
    position: absolute;
    left: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-dim);
}

.search-container input {
    padding-left: 35px;
    width: 100%;
}

.filter-container {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.filter-container select, .filter-container button {
    min-height: 40px;
    font-size: 14px;
}

.filter-container button {
    white-space: nowrap;
}

.search-results-info {
    margin: 10px 0;
    padding: 8px 12px;
    background: var(--bg-secondary);
    border-radius: 8px;
    font-size: 14px;
    color: var(--text-dim);
}
/* Deck Manager Styles */
.deck-manager-actions {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
}

.decks-list {
    max-height: 400px;
    overflow-y: auto;
}

.deck-item, .folder-item {
    padding: 12px 15px;
    background: var(--bg-secondary);
    border-radius: 8px;
    margin-bottom: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.deck-item:hover, .folder-item:hover {
    background: var(--primary);
    transform: translateX(5px);
}

.folder-item {
    background: var(--bg-card);
}

.deck-info {
    display: flex;
    flex-direction: column;
}

.deck-name {
    font-weight: 600;
    margin-bottom: 4px;
}

.deck-meta {
    font-size: 12px;
    color: var(--text-dim);
}

.deck-actions {
    display: flex;
    gap: 8px;
}

.deck-actions button {
    padding: 4px 8px;
    font-size: 12px;
    margin: 0;
}

.folder-contents {
    margin-left: 20px;
    border-left: 2px solid var(--bg-secondary);
    padding-left: 15px;
    margin-top: 10px;
}

.collapsible .folder-contents {
    display: none;
}

.collapse-toggle {
    margin-right: 8px;
    cursor: pointer;
}
.cloze-toolbar { display:flex; align-items:center; gap:.5rem; margin:.5rem 0; flex-wrap:wrap; }
.cloze-toolbar button { padding:.4rem .6rem; border-radius:.5rem; border:1px solid var(--border, #ddd); cursor:pointer; }
.cloze-tip { opacity:.8; font-size:.9rem; }

.cloze-preview { margin-top:.5rem; padding:.75rem; border:1px dashed var(--muted, #bbb); border-radius:.5rem; }
.cloze-gap { padding:0 .25rem; border-bottom:2px solid currentColor; font-weight:600; }
.cloze-hint { opacity:.7; font-style:italic; margin-left:.25rem; }
.cloze-error { color:#b00020; margin-top:.35rem; }

    </style>
</head>
<body>
    <div class="app-container">
        <!-- Study Stats Bar -->
        <div class="study-stats">
            <div class="stat-item">
                <div class="stat-number" id="newCards">0</div>
                <div class="stat-label">New</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="learningCards">0</div>
                <div class="stat-label">Learning</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="reviewCards">0</div>
                <div class="stat-label">Review</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="streakDays">0</div>
                <div class="stat-label">Streak</div>
            </div>
        </div>
        <div class="search-filter-bar">
            <div class="search-container">
                <i class="fas fa-search"></i>
                <input type="text" id="searchInput" placeholder="Search questions or answers...">
            </div>
            <div class="filter-container">
                <select id="tagFilter">
                    <option value="">All Tags</option>
                </select>
                <select id="difficultyFilter">
                    <option value="">All Difficulties</option>
                    <option value="easy">Easy</option>
                    <option value="normal">Normal</option>
                    <option value="hard">Hard</option>
                </select>
                <button onclick="applyFilters()">Apply Filters</button>
                <button onclick="clearFilters()">Clear</button>
            </div>
        </div>
        <!-- Presets Dropdown Menu -->
        <div class="presets-container">
            <button class="dropdown-btn" onclick="toggleDropdown()">
                Menu ▼
            </button>
            <div id="presetDropdown" class="preset-dropdown-content">
                <button class="export-csv-btn" onclick="exportToCSV()">
    <i class="fas fa-file-csv"></i> Export to CSV
</button>
<button class="export-anki-btn" onclick="exportToAnki()">
    <i class="fas fa-download"></i> Export for Anki
</button>
                <button onclick="showStatsModal()">
                    <i class="fas fa-chart-bar"></i> Statistics
                </button>
                <button onclick="showSettingsModal()">
                    <i class="fas fa-cog"></i> Settings
                </button>
                <button class="save-preset-btn" onclick="savePreset()">
                    <i class="fas fa-save"></i> Save Deck
                </button>
                <button class="export-preset-btn" onclick="exportPreset()">
                    <i class="fas fa-share"></i> Export Deck
                </button>
                <button class="import-preset-btn" onclick="importPreset()">
                    <i class="fas fa-file-import"></i> Import Deck
                </button>
                <button class="edit-preset-btn" onclick="showEditModal()">
                    <i class="fas fa-edit"></i> Edit Current Deck
                </button>
                <button onclick="showSessionTimerModal()">
                    <i class="fas fa-hourglass-start"></i> Study Session
                </button>

                <button onclick="showAnkiImportModal()">
                    <i class="fas fa-file-import"></i> Import from Anki
                </button>
                <button onclick="showDeckManager()">
                    <i class="fas fa-layer-group"></i> Deck Manager
                </button>
                <ul id="presetList"></ul>
            </div>
        </div>

        <h1>Decked Out</h1>

        <!-- Study Mode Toggle -->
        <div class="study-mode-toggle">
            <button class="mode-btn active" onclick="setStudyMode('spaced')">Spaced Review</button>
            <button class="mode-btn" onclick="setStudyMode('browse')">Browse All</button>
        </div>

        <!-- Card Info Bar -->
        <div class="card-info">
            <div class="flashcard-counter">Card 1 of 1</div>
            <div class="due-status" id="dueStatus">
                <div class="due-item due-new"><i class="fas fa-star"></i> <span id="dueNew">0</span></div>
                <div class="due-item due-learning"><i class="fas fa-clock"></i> <span id="dueLearning">0</span></div>
                <div class="due-item due-review"><i class="fas fa-check"></i> <span id="dueReview">0</span></div>
            </div>
        </div>

        <div class="carousel">
            <div class="flashcard ghost left"></div>
            <div class="flashcard main" id="flashcard">
                <div class="card-metadata">
                    <div class="card-tags" id="cardTags"></div>
                    <div class="card-interval" id="cardInterval"></div>
                </div>
                <div class="card-face front" id="card-front">
                    Click to Reveal Answer
                </div>
                <div class="card-face back" id="card-back">Answer</div>
            </div>
            <div class="flashcard ghost right"></div>
        </div>

        <div class="confidence-buttons" id="confidenceButtons">
            <button class="confidence-btn again" onclick="rateCard(1)">
                <div>
                    <i class="fas fa-times"></i> Again
                    <div class="interval-time" id="againTime">1m</div>
                </div>
            </button>
            <button class="confidence-btn hard" onclick="rateCard(2)">
                <div>
                    <i class="fas fa-frown"></i> Hard
                    <div class="interval-time" id="hardTime">6m</div>
                </div>
            </button>
            <button class="confidence-btn good" onclick="rateCard(3)">
                <div>
                    <i class="fas fa-smile"></i> Good
                    <div class="interval-time" id="goodTime">1d</div>
                </div>
            </button>
            <button class="confidence-btn easy" onclick="rateCard(4)">
                <div>
                    <i class="fas fa-star"></i> Easy
                    <div class="interval-time" id="easyTime">4d</div>
                </div>
            </button>
        </div>

        <div class="navigation-buttons">
            <button class="prev-btn" onclick="prevCard()">
                <i class="fas fa-arrow-left"></i> Previous
            </button>
            <button class="next-btn" onclick="nextCard()">
                Next <i class="fas fa-arrow-right"></i>
            </button>
        </div>

        <button class="clear-btn" onclick="clearAllFlashcards()">
            <i class="fas fa-trash"></i> Clear All Flashcards
        </button>

        <h2>Create a Flashcard</h2>
        
        <!-- Card Type Selector -->
        <div class="card-type-selector">
            <button class="card-type-btn active" onclick="setCardType('basic')" data-type="basic">Basic</button>
            <button class="card-type-btn" onclick="setCardType('cloze')" data-type="cloze">Cloze Deletion</button>
            <button class="card-type-btn" onclick="setCardType('reverse')" data-type="reverse">Basic (Reverse)</button>
        </div>

        <form id="flashcard-form">
            <div id="basicFields">
                <textarea id="question" placeholder="Enter question (press Enter for new line)" required rows="3"></textarea>
                <textarea id="answer" placeholder="Enter answer (press Enter for new line)" required rows="3"></textarea>
            </div>
            
            <div id="clozeFields" style="display:none;">
            <div class="cloze-toolbar" aria-label="Cloze tools">
                <button type="button" id="clozeWrapBtn" title="Wrap selection with next cN">Wrap selection</button>
                <button type="button" id="clozeNextBtn" title="Insert next cN at cursor">Insert {{cN::…}}</button>
                <span class="cloze-tip">Tip: use the same number (e.g., c1) on multiple blanks to bundle them into one card.</span>
            </div>

            <textarea id="clozeText"
                        placeholder="Type a sentence and hide bits like {{c1::glucose}} or with a hint {{c2::mitochondria::organelle}}"
                        rows="5"
                        aria-label="Cloze text"></textarea>

            <div id="clozePreview" class="cloze-preview" aria-live="polite"></div>
            <div id="clozeError" class="cloze-error" role="alert" style="display:none;"></div>
            </div>

            
            <div class="form-row">
                <div class="tags-input">
                    <input type="text" id="tags" placeholder="Tags (comma separated)" />
                    <div class="tag-suggestions" id="tagSuggestions"></div>
                </div>
                <select id="difficulty">
                    <option value="normal">Normal Difficulty</option>
                    <option value="easy">Easy</option>
                    <option value="hard">Hard</option>
                </select>
                <!-- Image Upload Section -->
<div class="image-upload-container">
    <div class="upload-btn" onclick="document.getElementById('imageUpload').click()">
        <i class="fas fa-image"></i>
        <p>Click to add an image (optional)</p>
    </div>
    <input type="file" id="imageUpload" accept="image/*" style="display: none;" onchange="handleImageUpload(this)">
    
    <div class="image-preview" id="imagePreview">
        <img id="previewImage" src="" alt="Image preview">
        <button class="remove-image" onclick="removeImage()">
            <i class="fas fa-times"></i>
        </button>
    </div>
</div>
            </div>
            
            <button type="submit" id="addFlashcardButton">
                <i class="fas fa-plus"></i> Add Flashcard
            </button>
        </form>

        <button id="bulkImportButton" class="bulk-import-btn" onclick="showBulkImportModal()">
            <i class="fas fa-file-import"></i> Bulk Import
        </button>

        <!-- Statistics Modal -->
        <div id="statsModal" class="modal">
            <div class="modal-content">
                <!-- Inside the statsModal content, after the stats-grid -->
<button onclick="showAgainCards()" style="margin-top: 20px;">
    <i class="fas fa-redo"></i> View Again-Rated Cards
</button>
                <span class="close" onclick="closeStatsModal()">&times;</span>
                <h2>Study Statistics</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Total Cards</h3>
                        <div class="big-number" id="totalCardsStats">0</div>
                    </div>
                    <div class="stat-card">
                        <h3>Cards Studied Today</h3>
                        <div class="big-number" id="studiedTodayStats">0</div>
                    </div>
                    <div class="stat-card">
                        <h3>Average Retention</h3>
                        <div class="big-number" id="retentionStats">0%</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="retentionProgress"></div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <h3>Study Streak</h3>
                        <div class="big-number" id="streakStats">0</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settingsModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeSettingsModal()">&times;</span>
                <h2>Settings</h2>
                <form id="settingsForm">
                    <h3>Spaced Repetition</h3>
                    <label>New cards per day:</label>
                    <input type="number" id="newCardsPerDay" value="20" min="0" max="100">
                    
                    <label>Review cards per day:</label>
                    <input type="number" id="reviewCardsPerDay" value="50" min="0" max="200">
                    
                    <h3>Intervals</h3>
                    <label>Learning steps (minutes):</label>
                    <input type="text" id="learningSteps" value="1,10" placeholder="1,10,60">
                    
                    <label>Graduating interval (days):</label>
                    <input type="number" id="graduatingInterval" value="1" min="1" max="10">
                    
                    <label>Easy interval (days):</label>
                    <input type="number" id="easyInterval" value="4" min="2" max="30">
                    
                    <button type="submit">Save Settings</button>
                </form>
            </div>
        </div>

        <!-- Other modals remain the same -->
        <div id="bulkImportModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeBulkImportModal()">&times;</span>
                <h2>Bulk Import Flashcards</h2>
                <p>Enter your questions and answers in the following format:</p>
                <pre>
Q1: What is the capital of France?
A1: Paris
Q2: What is the largest planet?
A2: Jupiter</pre>
                <textarea id="bulkTextInput" rows="10" placeholder="Enter your flashcards here..."></textarea>
                <button class="import-btn" onclick="processBulkImport()">
                    <i class="fas fa-file-import"></i> Import
                </button>
            </div>
        </div>

        <!-- Edit Deck Modal -->
        <div id="editDeckModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeEditModal()">&times;</span>
                <h2>Edit Current Deck</h2>
                <div id="deckEditorContainer"></div>
                <button class="save-edit-btn" onclick="saveDeckEdits()">
                    <i class="fas fa-save"></i> Save Changes
                </button>
            </div>
        </div>
    </div>
    <!-- Again Cards Modal -->
<div id="againCardsModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeAgainCardsModal()">&times;</span>
        <h2>Cards Rated as "Again"</h2>
        <!-- Add this after the study mode toggle -->
<div class="hardest-cards-section" style="margin: 15px 0; text-align: center;">
    <button class="btn-hardest-mode" onclick="startHardestCardsReview()" style="background-color: #e74c3c;">
        <i class="fas fa-fire"></i> Review Hardest Cards
    </button>
    <p style="font-size: 12px; color: var(--text-dim); margin-top: 5px;">
        Focus on cards you've struggled with
    </p>
</div>
        <div id="againCardsList" style="max-height: 400px; overflow-y: auto;">
            <!-- Cards will be populated here -->
        </div>
    </div>
</div>
<!-- Session Timer Modal -->
<div id="sessionTimerModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeSessionTimerModal()">&times;</span>
        <h2>Study Session Options</h2>
        <div class="session-options">
            <div class="session-option" onclick="startTimedSession(10)">
                <i class="fas fa-bolt"></i>
                <h3>10-Minute Sprint</h3>
                <p>Study as many cards as possible in 10 minutes</p>
            </div>
            <div class="session-option" onclick="showCardLimitInput()">
                <i class="fas fa-bullseye"></i>
                <h3>Card Target</h3>
                <p>Study until you've reviewed X cards</p>
            </div>
        </div>
        <div id="cardLimitInput" style="display: none; margin-top: 20px;">
            <input type="number" id="cardLimit" placeholder="Number of cards" min="1" max="100">
            <button onclick="startCardLimitSession()">Start Session</button>
        </div>
        <div id="sessionProgress" style="display: none; margin-top: 20px;">
            <div class="session-info">
                <div id="sessionTimer">10:00</div>
                <div id="sessionCardsCompleted">0 cards reviewed</div>
            </div>
            <button onclick="endSession()" style="background-color: var(--danger);">End Session</button>
        </div>
    </div>
</div>
<!-- Quizlet Import Modal -->
<div id="quizletImportModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeQuizletImportModal()">&times;</span>
        <h2>Import from Quizlet</h2>
        <div class="import-options">
            <div class="import-option">
                <h3>Option 1: Paste Quizlet Export</h3>
                <textarea id="quizletExportText" placeholder="Paste Quizlet export text here..." rows="6"></textarea>
                <button onclick="processQuizletExport()">Process Export</button>
            </div>
            <div class="import-option">
                <h3>Option 2: Enter Quizlet URL</h3>
                <input type="text" id="quizletUrl" placeholder="https://quizlet.com/...">
                <button onclick="fetchQuizletData()">Fetch from URL</button>
            </div>
        </div>
        <div id="quizletPreview" style="display: none; margin-top: 20px;">
            <h3>Preview</h3>
            <div id="quizletPreviewList"></div>
            <button onclick="importQuizletCards()">Import Flashcards</button>
        </div>
    </div>
</div>
<!-- Hardest Cards Review Modal -->
<div id="hardestCardsModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeHardestCardsModal()">&times;</span>
        <h2>Hardest Cards Review</h2>
        <div class="session-info">
            <div id="hardestCardsProgress">0/0 cards reviewed</div>
            <div id="hardestCardsStats">0% correct</div>
        </div>
        <div class="carousel" id="hardestCarousel">
            <!-- Cards will be loaded here -->
        </div>
        <div class="confidence-buttons" id="hardestConfidenceButtons">
            <!-- Confidence buttons will be loaded here -->
        </div>
        <div class="navigation-buttons">
            <button onclick="endHardestCardsReview()" style="background-color: #e74c3c;">
                <i class="fas fa-times"></i> End Session
            </button>
        </div>
    </div>
</div>
<!-- Anki Import Modal -->
<div id="ankiImportModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeAnkiImportModal()">&times;</span>
        <h2>Import from Anki</h2>
        <p>Upload an Anki .apkg file or paste exported text:</p>
        
        <div class="import-option">
            <h3>Option 1: Upload .apkg file</h3>
            <input type="file" id="ankiFileUpload" accept=".apkg">
            <button onclick="processAnkiFile()">Process File</button>
        </div>
        
        <div class="import-option">
            <h3>Option 2: Paste exported text</h3>
            <textarea id="ankiExportText" placeholder="Paste your Anki export here..." rows="6"></textarea>
            <button onclick="processAnkiText()">Process Text</button>
        </div>
        
        <div id="ankiPreview" style="display: none; margin-top: 20px;">
            <h3>Preview</h3>
            <div id="ankiPreviewList"></div>
            <button onclick="importAnkiCards()">Import Flashcards</button>
        </div>
    </div>
</div>
<!-- Deck Manager Modal -->
<div id="deckManagerModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeDeckManager()">&times;</span>
        <h2>Deck Manager</h2>
        
        <div class="deck-manager-actions">
            <button onclick="createNewDeck()">
                <i class="fas fa-plus"></i> New Deck
            </button>
            <button onclick="createNewFolder()">
                <i class="fas fa-folder-plus"></i> New Folder
            </button>
        </div>
        
        <div class="decks-container">
            <div id="decksList" class="decks-list">
                <!-- Decks will be populated here -->
            </div>
        </div>
    </div>
</div>

<!-- New Deck/Folder Creation Modal -->
<div id="createItemModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeCreateItemModal()">&times;</span>
        <h2 id="createItemTitle">Create New Deck</h2>
        
        <form id="createItemForm">
            <input type="text" id="itemName" placeholder="Name" required>
            <select id="parentFolder" style="display: none;">
                <option value="">Root Level</option>
            </select>
            <button type="submit">Create</button>
        </form>
    </div>
</div>

    <script>
// Enhanced Flashcard App with Anki-like Features
let flashcards = [];
let currentCardIndex = 0;
let presets = JSON.parse(localStorage.getItem("flashcardPresets")) || [];
let studyMode = 'spaced'; // 'spaced' or 'browse'
let currentCardType = 'basic';
let settings = JSON.parse(localStorage.getItem("flashcardSettings")) || {
    newCardsPerDay: 20,
    reviewCardsPerDay: 50,
    learningSteps: [1, 10],
    graduatingInterval: 1,
    easyInterval: 4
};
let dailyStats = JSON.parse(localStorage.getItem("dailyStats")) || {};
let allTags = new Set();

const carousel = document.querySelector(".carousel");
let sessionActive = false;
let sessionTimer = null;
let sessionType = null;
let sessionEndTime = null;
let sessionCardLimit = 0;
let cardsReviewedInSession = 0;
let ratingInProgress = false;

// Spaced Repetition Algorithm (SM-2)
class SpacedRepetition {
    static calculateNextReview(card, rating) {
        const now = new Date();
        let interval, easeFactor, repetitions;
        
        // Initialize card data if new
        if (!card.easeFactor) card.easeFactor = 2.5;
        if (!card.repetitions) card.repetitions = 0;
        if (!card.interval) card.interval = 0;
        if (!card.lastReviewed) card.lastReviewed = now.toISOString();
        if (!card.cardType) card.cardType = 'new';
        
        easeFactor = card.easeFactor;
        repetitions = card.repetitions;
        interval = card.interval;
        
        // SM-2 Algorithm implementation
        if (rating >= 3) { // Correct response
            if (repetitions === 0) {
                interval = 1;
            } else if (repetitions === 1) {
                interval = settings.graduatingInterval;
            } else {
                interval = Math.round(interval * easeFactor);
            }
            repetitions++;
            card.cardType = repetitions <= 2 ? 'learning' : 'review';
        } else { // Incorrect response
            repetitions = 0;
            interval = 0;
            card.cardType = 'learning';
        }
        
        // Update ease factor
        easeFactor = easeFactor + (0.1 - (5 - rating) * (0.08 + (5 - rating) * 0.02));
        easeFactor = Math.max(1.3, easeFactor);
        
        // Calculate next review date
        const nextReview = new Date(now);
        if (rating === 1) { // Again
            nextReview.setMinutes(nextReview.getMinutes() + 1);
        } else if (rating === 2) { // Hard
            nextReview.setMinutes(nextReview.getMinutes() + 6);
        } else if (interval === 0) {
            nextReview.setMinutes(nextReview.getMinutes() + settings.learningSteps[0]);
        } else {
            nextReview.setDate(nextReview.getDate() + interval);
        }
        
        // Update card
        card.easeFactor = easeFactor;
        card.repetitions = repetitions;
        card.interval = interval;
        card.nextReview = nextReview.toISOString();
        card.lastReviewed = now.toISOString();
        
        return card;
    }
    
    static getIntervalText(days) {
        if (days < 1) return `${Math.round(days * 24 * 60)}m`;
        if (days < 30) return `${Math.round(days)}d`;
        if (days < 365) return `${Math.round(days / 30)}mo`;
        return `${Math.round(days / 365)}y`;
    }
}

// Initialize the app
function init() {
    migrateCards();  
    loadSettings();
    initDeckManager();
    updateStudyStats();
    updateFlashcardCounter();
    createGhostCards();
    loadAllTags();
    updateDailyStats();
    initSearchFilter();
    
    if (flashcards.length === 0) {
        addDefaultFlashcards();
    } else {
        loadCard(document.querySelector(".main"), currentCardIndex);
    }
    
    setupEventListeners();
    updateIntervalPredictions();
}

function setupEventListeners() {
    // Keyboard navigation
    document.addEventListener('keydown', handleKeyNavigation, { capture: true });
    // Flip card on click
    document.addEventListener("click", (e) => {
        if (e.target.closest(".main")) {
            e.target.closest(".main").classList.toggle("flipped");
        }
    });

    // Form submission
    document.getElementById("flashcard-form").addEventListener("submit", (e) => {
        e.preventDefault();
        addFlashcard();
    });

    // Settings form
    document.getElementById("settingsForm").addEventListener("submit", (e) => {
        e.preventDefault();
        saveSettings();
    });

    // Tag input with suggestions
    const tagsInput = document.getElementById("tags");
    tagsInput.addEventListener("input", showTagSuggestions);
    tagsInput.addEventListener("blur", () => {
        setTimeout(() => hideTagSuggestions(), 200);
    });
}

// Study Mode Management
function setStudyMode(mode) {
    studyMode = mode;
    document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelector(`[onclick="setStudyMode('${mode}')"]`).classList.add('active');
    
    if (mode === 'spaced') {
        filterDueCards();
    } else {
        currentCardIndex = 0;
    }
    
    updateStudyStats();
    updateFlashcardCounter();
    resetCarousel();
}

function filterDueCards() {
    const now = new Date();
    const dueCards = flashcards.filter(card => {
        if (!card.nextReview) return true; // New cards
        return new Date(card.nextReview) <= now;
    });
    
    if (dueCards.length === 0) {
        // No cards due, show a message
        const mainCard = document.querySelector(".main");
        if (mainCard) {
            mainCard.querySelector(".front").textContent = "No cards due for review!";
            mainCard.querySelector(".back").textContent = "Come back later or switch to Browse mode";
        }
        return;
    }
    
    // Sort by priority: new cards first, then by due date
    dueCards.sort((a, b) => {
        if (!a.nextReview && !b.nextReview) return 0;
        if (!a.nextReview) return -1;
        if (!b.nextReview) return 1;
        return new Date(a.nextReview) - new Date(b.nextReview);
    });
    
    flashcards = dueCards;
    currentCardIndex = 0;
}
function isTypingContext(target) {
  if (!target) return false;
  if (target.isContentEditable) return true;
  const tag = target.tagName ? target.tagName.toLowerCase() : '';
  // Typing if we're in inputs, textareas, selects, deck form, or any open modal
  return (
    tag === 'input' ||
    tag === 'textarea' ||
    tag === 'select' ||
    !!target.closest('#flashcard-form') ||
    !!Array.from(document.querySelectorAll('.modal')).some(m => m.style.display === 'block')
  );
}

function handleKeyNavigation(e) {
  // If cursor is in a typing context, let the keystrokes through
  if (isTypingContext(e.target)) return;

  // Space = flip current card
  if (e.key === ' ') {
    e.preventDefault();
    const mainCard = document.querySelector('.main');
    if (mainCard) mainCard.classList.toggle('flipped');
    return;
  }

  // 1–4 = rate (flip first if needed so the user sees the answer)
  if (e.key >= '1' && e.key <= '4') {
    e.preventDefault();
    const rating = parseInt(e.key, 10);
    const main = document.querySelector('.main');
    if (main && !main.classList.contains('flipped')) {
      main.classList.add('flipped');
      setTimeout(() => rateCard(rating), 300);
    } else {
      rateCard(rating);
    }
    return;
  }

  // Arrows = navigate
  if (e.key === 'ArrowRight') { e.preventDefault(); nextCard(); return; }
  if (e.key === 'ArrowLeft')  { e.preventDefault(); prevCard(); return; }
}
// Card Type Management
function setCardType(type) {
  currentCardType = type;
  document.querySelectorAll('.card-type-btn').forEach(btn => btn.classList.remove('active'));
  document.querySelector(`[data-type="${type}"]`).classList.add('active');

  // Show/hide fields
  const basicBlock = document.getElementById('basicFields');
  const clozeBlock = document.getElementById('clozeFields');
  basicBlock.style.display = (type === 'basic' || type === 'reverse') ? 'block' : 'none';
  clozeBlock.style.display = (type === 'cloze') ? 'block' : 'none';

  // Toggle required attrs so hidden inputs don’t block submit
  const q = document.getElementById('question');
  const a = document.getElementById('answer');
  const c = document.getElementById('clozeText');
  if (q && a && c) {
    const isCloze = (type === 'cloze');
    q.required = a.required = !isCloze;
    c.required = isCloze;
  }

  if (type === 'cloze') {
    requestAnimationFrame(() => {
      const ta = document.getElementById('clozeText');
      ta && ta.focus();
      updateClozePreview(); // keep preview in sync
    });
  }
}


// Enhanced Card Rating with Spaced Repetition
// Enhanced Card Rating with Spaced Repetition
function rateCard(rating) {
    if (this.ratingInProgress) return;
    this.ratingInProgress = true;
    if (flashcards.length === 0) return;
    
    const card = flashcards[currentCardIndex];
    
    // Add rating history if it doesn't exist
    if (!card.ratingHistory) {
        card.ratingHistory = [];
    }
    
    SpacedRepetition.calculateNextReview(card, rating);
    
    // Update daily stats
    updateDailyStats(rating);
    
    // Visual feedback
const btns = document.querySelectorAll('#confidenceButtons .confidence-btn');
const confidenceBtn = btns[rating - 1];
if (confidenceBtn) {
    confidenceBtn.classList.add('pulse');
    setTimeout(() => confidenceBtn.classList.remove('pulse'), 300);
}
        // Record this rating
    card.ratingHistory.push({
        rating: rating,
        date: new Date().toISOString()
    });
    if (sessionActive) trackCardReview();
    // Save progress
    saveProgress();
    
    // Move to next card or end session
    setTimeout(() => {
        if (studyMode === 'spaced') {
            // Remove card from current session if it's not due again soon
            const nextReview = new Date(card.nextReview);
            const now = new Date();
            const minutesUntilNext = (nextReview - now) / (1000 * 60);
            
            if (minutesUntilNext > 10) {
                flashcards.splice(currentCardIndex, 1);
                if (currentCardIndex >= flashcards.length) {
                    currentCardIndex = 0;
                }
            }
            
            if (flashcards.length === 0) {
                showSessionComplete();
                return;
            }
        }
        
        nextCard();
        updateStudyStats();
    }, 300);
    
    setTimeout(() => { this.ratingInProgress = false; }, 500);
}

function showSessionComplete() {
    const mainCard = document.querySelector(".main");
    if (mainCard) {
        mainCard.querySelector(".front").textContent = "Study session complete! 🎉";
        mainCard.querySelector(".back").textContent = "Great job! Come back later for more reviews.";
        mainCard.classList.remove("flipped");
    }
    
    // Hide confidence buttons
    document.getElementById("confidenceButtons").style.display = "none";
    
    // Show celebration message
    setTimeout(() => {
        alert("Congratulations! You've completed your study session for now. Keep up the great work!");
    }, 500);
}

// Interval Predictions
function updateIntervalPredictions() {
    if (flashcards.length === 0) return;
    
    const card = flashcards[currentCardIndex];
    const predictions = calculateIntervalPredictions(card);
    
    document.getElementById("againTime").textContent = predictions.again;
    document.getElementById("hardTime").textContent = predictions.hard;
    document.getElementById("goodTime").textContent = predictions.good;
    document.getElementById("easyTime").textContent = predictions.easy;
}

function calculateIntervalPredictions(card) {
  const predictions = {};
  const labels = ['again', 'hard', 'good', 'easy'];

  for (let rating = 1; rating <= 4; rating++) {
    const testCard = JSON.parse(JSON.stringify(card)); // fresh clone each iteration
    const result = SpacedRepetition.calculateNextReview(testCard, rating);
    const now = new Date();
    const next = new Date(result.nextReview);
    const diffDays = (next - now) / (1000 * 60 * 60 * 24);
    predictions[labels[rating - 1]] = SpacedRepetition.getIntervalText(diffDays);
  }

  return predictions;
}


// Enhanced Statistics
function updateStudyStats() {
    const stats = calculateStudyStats();
    
    document.getElementById("newCards").textContent = stats.newCards;
    document.getElementById("learningCards").textContent = stats.learningCards;
    document.getElementById("reviewCards").textContent = stats.reviewCards;
    document.getElementById("streakDays").textContent = stats.streakDays;
    
    // Update due status
    document.getElementById("dueNew").textContent = stats.dueNew;
    document.getElementById("dueLearning").textContent = stats.dueLearning;
    document.getElementById("dueReview").textContent = stats.dueReview;
}

function calculateStudyStats() {
    const now = new Date();
    const today = now.toDateString();
    
    let newCards = 0, learningCards = 0, reviewCards = 0;
    let dueNew = 0, dueLearning = 0, dueReview = 0;
    
    flashcards.forEach(card => {
        const isDue = !card.nextReview || new Date(card.nextReview) <= now;
        
        switch (card.cardType || 'new') {
            case 'new':
                newCards++;
                if (isDue) dueNew++;
                break;
            case 'learning':
                learningCards++;
                if (isDue) dueLearning++;
                break;
            case 'review':
                reviewCards++;
                if (isDue) dueReview++;
                break;
        }
    });
    
    // Calculate streak
    const streakDays = calculateStreak();
    
    return {
        newCards, learningCards, reviewCards,
        dueNew, dueLearning, dueReview, streakDays
    };
}

function calculateStreak() {
    const today = new Date();
    let streak = 0;
    let currentDate = new Date(today);
    
    while (true) {
        const dateStr = currentDate.toDateString();
        if (dailyStats[dateStr] && dailyStats[dateStr].studied > 0) {
            streak++;
            currentDate.setDate(currentDate.getDate() - 1);
        } else {
            break;
        }
    }
    
    return streak;
}

function updateDailyStats(rating = null) {
    const today = new Date().toDateString();
    
    if (!dailyStats[today]) {
        dailyStats[today] = {
            studied: 0,
            correct: 0,
            total: 0
        };
    }
    
    if (rating) {
        dailyStats[today].studied++;
        dailyStats[today].total++;
        if (rating >= 3) dailyStats[today].correct++;
    }
    
    localStorage.setItem("dailyStats", JSON.stringify(dailyStats));
}

// Enhanced Flashcard Creation
// Enhanced Flashcard Creation
function addFlashcard() {
    const tags = document.getElementById("tags").value.trim().split(',').map(t => t.trim()).filter(t => t);
    const difficulty = document.getElementById("difficulty").value;
    
    let cards = [];
    
    if (currentCardType === 'basic') {
        const question = document.getElementById("question").value.trim();
        const answer = document.getElementById("answer").value.trim();
        
        if (question && answer) {
            cards.push({
                question, answer, tags, difficulty,
                cardType: 'new',
                image: currentImageData,
                confidence: 0,
                easeFactor: 2.5, // Add default ease factor
                repetitions: 0,  // Add default repetitions
                interval: 0,     // Add default interval
                createdAt: new Date().toISOString(),
                ratingHistory: [] // Initialize rating history
            });
        }
    } else if (currentCardType === 'reverse') {
        const question = document.getElementById("question").value.trim();
        const answer = document.getElementById("answer").value.trim();
        
        if (question && answer) {
            cards.push(
                {
                    question, answer, tags, difficulty,
                    cardType: 'new',
                    confidence: 0,
                    easeFactor: 2.5,
                    repetitions: 0,
                    interval: 0,
                    createdAt: new Date().toISOString(),
                    ratingHistory: []
                },
                {
                    question: answer, answer: question, tags, difficulty,
                    cardType: 'new',
                    confidence: 0,
                    easeFactor: 2.5,
                    repetitions: 0,
                    interval: 0,
                    createdAt: new Date().toISOString(),
                    ratingHistory: []
                }
            );
        }
    } else if (currentCardType === 'cloze') {
        const clozeText = document.getElementById("clozeText").value.trim();
        const err = validateClozeBraces(clozeText);
        if (err) { alert(err); return; }
        cards = processClozeText(clozeText, tags, difficulty);
        if (!cards.length) { alert("No valid clozes found. Use {{c1::answer}} syntax."); return; }
    }

    
    if (cards.length > 0) {
        flashcards.push(...cards);
        
        // Add tags to global set
        tags.forEach(tag => allTags.add(tag));
        
        // Clear form including image
        clearForm();
        
        // Update UI
        if (flashcards.length === cards.length) {
            loadCard(document.querySelector(".main"), 0);
        }
        
        shuffleFlashcards();
        updateStudyStats();
        updateFlashcardCounter();
        createGhostCards();
        saveProgress();
    }
}

function processClozeText(text, tags, difficulty) {
  const cards = [];
  if (!text) return cards;

  // Match {{cN::content}} OR {{cN::content::hint}}
  const tokenRe = /\{\{c(\d+)::(.*?)(?:::(.*?))?\}\}/g;

  // Collect by cloze number (Anki-style: same number -> one card with multiple gaps)
  /** @type {Record<string,{full:string,content:string,hint?:string}[]>} */
  const clozes = {};
  let m;
  while ((m = tokenRe.exec(text)) !== null) {
    const num = m[1];
    const content = m[2];
    const hint = m[3];
    if (!clozes[num]) clozes[num] = [];
    clozes[num].push({ full: m[0], content, hint });
  }

  // Build a card for each cloze number
  Object.keys(clozes).forEach(num => {
    const group = clozes[num];

    // Question: hide only the target cN; reveal others
    const question = text
      // hide target number with [...]
      .replace(new RegExp(`\\{\\{c${num}::(.*?)(?:::(.*?))?\\}\\}`, 'g'),
               (_all, _content, hint) => `[...]${hint ? ` <span class="cloze-hint">(${hint})</span>` : ''}`)
      // reveal non-target numbers (show their content)
      .replace(/\{\{c\d+::(.*?)(?:::(.*?))?\}\}/g, (_all, content, hint) =>
               `${content}${hint ? ` <span class="cloze-hint">(${hint})</span>` : ''}`);

    // Answer: list of all hidden pieces for this number
    const answer = group.map(x => x.content).join(', ');

    cards.push({
      question,
      answer,
      tags,
      difficulty,
      image: currentImageData || null,
      cardType: 'new',
      confidence: 0,
      easeFactor: 2.5,
      repetitions: 0,
      interval: 0,
      createdAt: new Date().toISOString(),
      clozeText: text,
      clozeNumber: Number(num),
      ratingHistory: []
    });
  });

  return cards;
}

function getNextClozeIndex(text) {
  const re = /\{\{c(\d+)::/g;
  let m, max = 0;
  while ((m = re.exec(text)) !== null) max = Math.max(max, Number(m[1]));
  return max + 1 || 1;
}

function wrapSelectionWithCloze() {
  const ta = document.getElementById('clozeText');
  if (!ta) return;
  const { selectionStart:s, selectionEnd:e, value:v } = ta;
  const sel = v.slice(s, e);
  const next = getNextClozeIndex(v);
  const insert = sel
    ? `{{c${next}::${sel}}}`
    : `{{c${next}::}}`;
  const newVal = v.slice(0, s) + insert + v.slice(e);
  ta.value = newVal;
  // place caret inside if empty
  const caretPos = sel ? s + insert.length : s + `{{c${next}::`.length;
  ta.focus();
  ta.setSelectionRange(caretPos, caretPos);
  updateClozePreview();
}

function insertNextClozeAtCursor() {
  const ta = document.getElementById('clozeText');
  if (!ta) return;
  const { selectionStart:s, selectionEnd:e, value:v } = ta;
  const next = getNextClozeIndex(v);
  const insert = `{{c${next}::}}`;
  const newVal = v.slice(0, s) + insert + v.slice(e);
  ta.value = newVal;
  const caretPos = s + insert.length - 2; // put caret before the closing }}
  ta.focus();
  ta.setSelectionRange(caretPos, caretPos);
  updateClozePreview();
}

function validateClozeBraces(text) {
  // quick sanity checks
  const opens = (text.match(/\{\{/g) || []).length;
  const closes = (text.match(/\}\}/g) || []).length;
  if (opens !== closes) return "Unbalanced braces: make sure each '{{' has a matching '}}'.";

  // ensure at least one proper token exists
  if (!/\{\{c\d+::.*?\}\}/.test(text)) return "Add at least one cloze like {{c1::answer}}.";
  return null;
}

function renderClozePreview(text) {
  // convert tokens to a pretty preview; this mirrors processClozeText’s question logic
  return text
    .replace(/\{\{c(\d+)::(.*?)(?:::(.*?))?\}\}/g,
      (_all, _n, content, hint) =>
        `<span class="cloze-gap">[...]</span>${hint ? ` <span class="cloze-hint">(${hint})</span>` : ''}`);
}

function updateClozePreview() {
  const ta = document.getElementById('clozeText');
  const prev = document.getElementById('clozePreview');
  const err = document.getElementById('clozeError');
  if (!ta || !prev || !err) return;

  const msg = validateClozeBraces(ta.value);
  if (msg) {
    err.textContent = msg;
    err.style.display = 'block';
    prev.innerHTML = '';
    return;
  }
  err.style.display = 'none';
  prev.innerHTML = renderClozePreview(ta.value);
}


function clearForm() {
    document.getElementById("question").value = "";
    document.getElementById("answer").value = "";
    document.getElementById("clozeText").value = "";
    document.getElementById("tags").value = "";
    document.getElementById("difficulty").value = "normal";
    removeImage();
}

// Tag Management
function loadAllTags() {
    allTags.clear();
    flashcards.forEach(card => {
        if (card.tags) card.tags.forEach(tag => allTags.add(tag));
    });
}

function showTagSuggestions() {
    const input = document.getElementById("tags");
    const suggestions = document.getElementById("tagSuggestions");
    const value = input.value.toLowerCase();
    
    if (value.length < 2) {
        hideTagSuggestions();
        return;
    }
    
    const matchingTags = Array.from(allTags).filter(tag => 
        tag.toLowerCase().includes(value) && !input.value.includes(tag)
    );
    
    if (matchingTags.length === 0) {
        hideTagSuggestions();
        return;
    }
    
    suggestions.innerHTML = matchingTags.slice(0, 5).map(tag => 
        `<div class="tag-suggestion" onclick="addTag('${tag}')">${tag}</div>`
    ).join('');
    
    suggestions.style.display = 'block';
const pv = document.getElementById("clozePreview");
const er = document.getElementById("clozeError");
if (pv) pv.innerHTML = "";
if (er) er.style.display = "none";
}

function hideTagSuggestions() {
    document.getElementById("tagSuggestions").style.display = 'none';
}

function addTag(tag) {
    const input = document.getElementById("tags");
    const currentTags = input.value ? input.value.split(',').map(t => t.trim()) : [];
    
    if (!currentTags.includes(tag)) {
        currentTags.push(tag);
        input.value = currentTags.join(', ');
    }
    
    hideTagSuggestions();
}

// Settings Management
function loadSettings() {
    document.getElementById("newCardsPerDay").value = settings.newCardsPerDay;
    document.getElementById("reviewCardsPerDay").value = settings.reviewCardsPerDay;
    document.getElementById("learningSteps").value = settings.learningSteps.join(',');
    document.getElementById("graduatingInterval").value = settings.graduatingInterval;
    document.getElementById("easyInterval").value = settings.easyInterval;
}

function saveSettings() {
    settings.newCardsPerDay = parseInt(document.getElementById("newCardsPerDay").value);
    settings.reviewCardsPerDay = parseInt(document.getElementById("reviewCardsPerDay").value);
    settings.learningSteps = document.getElementById("learningSteps").value.split(',').map(s => parseInt(s.trim()));
    settings.graduatingInterval = parseInt(document.getElementById("graduatingInterval").value);
    settings.easyInterval = parseInt(document.getElementById("easyInterval").value);
    
    localStorage.setItem("flashcardSettings", JSON.stringify(settings));
    closeSettingsModal();
    alert("Settings saved successfully!");
}

// Progress Saving
function saveProgress() {
    const progressData = {
        flashcards: flashcards,
        settings: settings,
        dailyStats: dailyStats,
        lastSaved: new Date().toISOString()
    };
    
    localStorage.setItem("flashcardProgress", JSON.stringify(progressData));
}

function loadProgress() {
    const progressData = JSON.parse(localStorage.getItem("flashcardProgress"));
    if (progressData) {
        flashcards = progressData.flashcards || [];
        if (progressData.settings) settings = progressData.settings;
        if (progressData.dailyStats) dailyStats = progressData.dailyStats;
    }
}

// Card Display Enhancement
function loadCard(element, index) {
    if (!element) return;
    
    const front = element.querySelector(".front");
    const back = element.querySelector(".back");
    const tagsContainer = element.querySelector("#cardTags");
    const intervalContainer = element.querySelector("#cardInterval");
    
    if (front && back) {
        if (flashcards.length > 0 && index < flashcards.length) {
            const card = flashcards[index];
            
            // Clear previous content
            front.innerHTML = "";
            back.innerHTML = "";
            
// Add question text
const frontText = document.createElement('div');
frontText.textContent = card.question || 'No question available';
front.appendChild(frontText);

// If MC options exist, render them
if (Array.isArray(card.options) && card.options.length) {
  const list = document.createElement('ul');
  list.className = 'mc-options';
  card.options.forEach(o => {
    const li = document.createElement('li');
    li.textContent = `${o.label}) ${o.text}`;
    list.appendChild(li);
  });
  front.appendChild(list);
}

// Back: show answer and (if MC) the list with correct highlighted
const backText = document.createElement('div');
backText.textContent = card.answer || 'No answer available';
back.appendChild(backText);

if (Array.isArray(card.options) && card.options.length) {
  const list = document.createElement('ul');
  list.className = 'mc-options';
  card.options.forEach(o => {
    const li = document.createElement('li');
    li.textContent = `${o.label}) ${o.text}`;
    if (card.correctOption &&
        o.label.toLowerCase() === String(card.correctOption).toLowerCase()) {
      li.style.fontWeight = 'bold';
      li.style.textDecoration = 'underline';
    }
    list.appendChild(li);
  });
  back.appendChild(list);
}
            
            // Add image if exists
            if (card.image) {
                const frontImg = document.createElement("img");
                frontImg.src = card.image;
                frontImg.style.maxWidth = "100%";
                frontImg.style.maxHeight = "120px";
                frontImg.style.marginTop = "10px";
                frontImg.style.borderRadius = "4px";
                front.appendChild(frontImg);
                
                const backImg = document.createElement("img");
                backImg.src = card.image;
                backImg.style.maxWidth = "100%";
                backImg.style.maxHeight = "120px";
                backImg.style.marginTop = "10px";
                backImg.style.borderRadius = "4px";
                back.appendChild(backImg);
            }
            
            // Show tags
            if (tagsContainer && card.tags && card.tags.length > 0) {
                tagsContainer.innerHTML = card.tags.map(tag => 
                    `<span class="tag">${tag}</span>`
                ).join('');
            } else if (tagsContainer) {
                tagsContainer.innerHTML = '';
            }
            
            // Show interval info
            if (intervalContainer) {
                if (card.interval && card.interval > 0) {
                    intervalContainer.textContent = `${card.interval}d`;
                } else {
                    intervalContainer.textContent = 'New';
                }
            }
            
            element.classList.remove("flipped");
            updateIntervalPredictions();
        } else {
            front.textContent = "No cards available";
            back.textContent = "Add flashcards to begin";
            if (tagsContainer) tagsContainer.innerHTML = '';
            if (intervalContainer) intervalContainer.textContent = '';
        }
    }
}

// Modal Management
function showStatsModal() {
    updateStatsDisplay();
    document.getElementById("statsModal").style.display = "block";
    toggleDropdown();
}

function closeStatsModal() {
    document.getElementById("statsModal").style.display = "none";
}

function showSettingsModal() {
    loadSettings();
    document.getElementById("settingsModal").style.display = "block";
    toggleDropdown();
}

function closeSettingsModal() {
    document.getElementById("settingsModal").style.display = "none";
}

function updateStatsDisplay() {
    const stats = calculateDetailedStats();
    
    document.getElementById("totalCardsStats").textContent = stats.totalCards;
    document.getElementById("studiedTodayStats").textContent = stats.studiedToday;
    document.getElementById("retentionStats").textContent = `${stats.retention}%`;
    document.getElementById("streakStats").textContent = `${stats.streak} days`;
    
    // Update progress bar
    const progressBar = document.getElementById("retentionProgress");
    progressBar.style.width = `${stats.retention}%`;
}

function calculateDetailedStats() {
    const totalCards = flashcards.length;
    const today = new Date().toDateString();
    const todayStats = dailyStats[today] || { studied: 0, correct: 0, total: 0 };
    
    let totalStudied = 0, totalCorrect = 0;
    Object.values(dailyStats).forEach(day => {
        totalStudied += day.total || 0;
        totalCorrect += day.correct || 0;
    });
    
    const retention = totalStudied > 0 ? Math.round((totalCorrect / totalStudied) * 100) : 0;
    const streak = calculateStreak();
    
    return {
        totalCards,
        studiedToday: todayStats.studied,
        retention,
        streak
    };
}

// Rest of the original functions with enhancements
function createGhostCards() {
    document.querySelectorAll(".left, .right").forEach(card => card.remove());
    
    const leftGhost = document.createElement("div");
    leftGhost.classList.add("flashcard", "left");
    leftGhost.innerHTML = `
        <div class="card-metadata">
            <div class="card-tags" id="leftCardTags"></div>
            <div class="card-interval" id="leftCardInterval"></div>
        </div>
        <div class="card-face front"></div>
        <div class="card-face back"></div>
    `;
    carousel.appendChild(leftGhost);
    
    const rightGhost = document.createElement("div");
    rightGhost.classList.add("flashcard", "right");
    rightGhost.innerHTML = `
        <div class="card-metadata">
            <div class="card-tags" id="rightCardTags"></div>
            <div class="card-interval" id="rightCardInterval"></div>
        </div>
        <div class="card-face front"></div>
        <div class="card-face back"></div>
    `;
    carousel.appendChild(rightGhost);
    
    if (flashcards.length > 1) {
        const leftIndex = (currentCardIndex - 1 + flashcards.length) % flashcards.length;
        const rightIndex = (currentCardIndex + 1) % flashcards.length;
        loadCard(leftGhost, leftIndex);
        loadCard(rightGhost, rightIndex);
    }
}

function toggleDropdown() {
    const dropdown = document.getElementById("presetDropdown");
    dropdown.style.display = dropdown.style.display === "block" ? "none" : "block";
}

function savePreset() {
    if (flashcards.length === 0) {
        alert("Cannot save an empty flashcard set!");
        return;
    }
    
    const presetName = prompt("Enter a name for the preset:");
    if (presetName) {
        const existingIndex = presets.findIndex(p => p.name === presetName);
        const presetData = { 
            name: presetName, 
            cards: [...flashcards],
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            totalCards: flashcards.length,
            tags: Array.from(allTags)
        };
        
        if (existingIndex >= 0) {
            if (confirm("A preset with this name already exists. Overwrite?")) {
                presets[existingIndex] = presetData;
            } else {
                return;
            }
        } else {
            presets.push(presetData);
        }
        
        localStorage.setItem("flashcardPresets", JSON.stringify(presets));
        updatePresetList();
        alert(`Preset "${presetName}" saved successfully!`);
    }
}

function updatePresetList() {
    const presetList = document.getElementById("presetList");
    presetList.innerHTML = "";

    presets.sort((a, b) => new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt));

    presets.forEach((preset, index) => {
        const listItem = document.createElement("li");
        listItem.innerHTML = `
            <div class="preset-info">
                <div class="preset-name">${preset.name}</div>
                <div class="preset-meta">${preset.totalCards || preset.cards.length} cards</div>
            </div>
            <button class="delete-btn" onclick="event.stopPropagation(); deletePreset(${index})">
                <i class="fas fa-trash"></i>
            </button>
        `;
        listItem.onclick = () => loadPreset(index);
        presetList.appendChild(listItem);
    });
}

function deletePreset(index) {
    if (confirm(`Are you sure you want to delete "${presets[index].name}"?`)) {
        presets.splice(index, 1);
        localStorage.setItem("flashcardPresets", JSON.stringify(presets));
        updatePresetList();
    }
}

function loadPreset(index) {
    flashcards = JSON.parse(JSON.stringify(presets[index].cards));
    currentCardIndex = 0;
    shuffleFlashcards();
    resetCarousel();
    updateStudyStats();
    updateFlashcardCounter();
    loadAllTags();
    toggleDropdown();
}

function resetCarousel() {
    document.querySelectorAll(".flashcard").forEach(card => card.remove());
    
    const mainCard = document.createElement("div");
    mainCard.classList.add("flashcard", "main");
    mainCard.innerHTML = `
        <div class="card-metadata">
            <div class="card-tags" id="cardTags"></div>
            <div class="card-interval" id="cardInterval"></div>
        </div>
        <div class="card-face front"></div>
        <div class="card-face back"></div>
    `;
    carousel.appendChild(mainCard);
    
    createGhostCards();
    loadCard(document.querySelector(".main"), currentCardIndex);
    
    // Show confidence buttons again if they were hidden
    document.getElementById("confidenceButtons").style.display = "flex";
}

function shuffleFlashcards() {
    if (flashcards.length < 2) return;
    
    // Enhanced shuffle based on study mode
    if (studyMode === 'spaced') {
        // Sort by due date and priority
        flashcards.sort((a, b) => {
            const aDue = new Date(a.nextReview || 0);
            const bDue = new Date(b.nextReview || 0);
            
            // Prioritize overdue cards
            const now = new Date();
            const aOverdue = aDue < now;
            const bOverdue = bDue < now;
            
            if (aOverdue && !bOverdue) return -1;
            if (!aOverdue && bOverdue) return 1;
            
            return aDue - bDue;
        });
    } else {
        // Simple shuffle for browse mode
        for (let i = flashcards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
        }
    }
    
    currentCardIndex = 0;
}

function nextCard() {
    if (flashcards.length < 2) return;
    const newIndex = (currentCardIndex + 1) % flashcards.length;
    animateCardTransition(newIndex, "left");
}

function prevCard() {
    if (flashcards.length < 2) return;
    const newIndex = (currentCardIndex - 1 + flashcards.length) % flashcards.length;
    animateCardTransition(newIndex, "right");
}

function animateCardTransition(newIndex, direction) {
    const mainCard = document.querySelector(".main");
    const leftGhost = document.querySelector(".left");
    const rightGhost = document.querySelector(".right");

    mainCard.classList.add(direction);
    mainCard.classList.remove("main");
    
    const newMain = direction === "left" ? rightGhost : leftGhost;
    newMain.classList.add("main");
    newMain.classList.remove(direction === "left" ? "right" : "left");

    const newGhost = document.createElement("div");
    newGhost.classList.add("flashcard", direction === "left" ? "right" : "left");
    newGhost.innerHTML = `
        <div class="card-metadata">
            <div class="card-tags"></div>
            <div class="card-interval"></div>
        </div>
        <div class="card-face front"></div>
        <div class="card-face back"></div>
    `;
    carousel.appendChild(newGhost);

    const ghostIndex = direction === "left" 
        ? (newIndex + 1) % flashcards.length 
        : (newIndex - 1 + flashcards.length) % flashcards.length;
    loadCard(newGhost, ghostIndex);

    setTimeout(() => {
        const oldGhost = direction === "left" ? leftGhost : rightGhost;
        if (oldGhost) oldGhost.remove();
        
        currentCardIndex = newIndex;
        updateFlashcardCounter();
        updateIntervalPredictions();
    }, 300);
}

function updateFlashcardCounter() {
    const counter = document.querySelector(".flashcard-counter");
    if (counter) {
        counter.textContent = flashcards.length > 0 
            ? `Card ${currentCardIndex + 1} of ${flashcards.length}` 
            : "No cards available";
    }
}

function clearAllFlashcards() {
    if (flashcards.length === 0 || confirm("Are you sure you want to clear all flashcards?")) {
        flashcards = [];
        currentCardIndex = 0;
        
        const mainCard = document.querySelector(".main");
        if (mainCard) {
            mainCard.querySelector(".front").textContent = "Click to Reveal Answer";
            mainCard.querySelector(".back").textContent = "Answer";
            mainCard.classList.remove("flipped");
            
            const tagsContainer = mainCard.querySelector("#cardTags");
            const intervalContainer = mainCard.querySelector("#cardInterval");
            if (tagsContainer) tagsContainer.innerHTML = '';
            if (intervalContainer) intervalContainer.textContent = '';
        }
        
        createGhostCards();
        updateFlashcardCounter();
        updateStudyStats();
        saveProgress();
    }
}

// Enhanced Deck Editor
function showEditModal() {
    if (flashcards.length === 0) {
        alert("No flashcards to edit!");
        return;
    }
    
    const editorContainer = document.getElementById("deckEditorContainer");
    editorContainer.innerHTML = "";
    
    flashcards.forEach((card, index) => {
        const cardElement = document.createElement("div");
        cardElement.className = "deck-editor-item";
        
        let imageSection = '';
        if (card.image) {
            imageSection = `
                <div class="image-preview" style="display: block; margin: 10px 0;">
                    <img src="${card.image}" style="max-width: 100px; max-height: 100px; border-radius: 4px;">
                    <button type="button" onclick="removeCardImage(${index})" style="background: var(--danger); padding: 4px 8px; margin-left: 10px;">
                        Remove Image
                    </button>
                </div>
            `;
        }
        
        cardElement.innerHTML = `
            <div class="deck-editor-fields">
                <textarea class="edit-question" placeholder="Question">${card.question}</textarea>
                <textarea class="edit-answer" placeholder="Answer">${card.answer}</textarea>
            </div>
            ${imageSection}
            <div class="deck-editor-meta">
                <input type="text" class="edit-tags" placeholder="Tags" value="${(card.tags || []).join(', ')}">
                <select class="edit-difficulty">
                    <option value="easy" ${card.difficulty === 'easy' ? 'selected' : ''}>Easy</option>
                    <option value="normal" ${card.difficulty === 'normal' || !card.difficulty ? 'selected' : ''}>Normal</option>
                    <option value="hard" ${card.difficulty === 'hard' ? 'selected' : ''}>Hard</option>
                </select>
                <input type="file" class="edit-image" accept="image/*" onchange="updateCardImage(this, ${index})">
                <button onclick="removeCardFromEditor(${index})">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
        editorContainer.appendChild(cardElement);
    });
    
    document.getElementById("editDeckModal").style.display = "block";
    toggleDropdown();
}

function closeEditModal() {
    document.getElementById("editDeckModal").style.display = "none";
}

function saveDeckEdits() {
    const editedCards = [];
    const editorItems = document.querySelectorAll(".deck-editor-item");
    
    editorItems.forEach((item, index) => {
        const question = item.querySelector(".edit-question").value.trim();
        const answer = item.querySelector(".edit-answer").value.trim();
        const tags = item.querySelector(".edit-tags").value.trim().split(',').map(t => t.trim()).filter(t => t);
        const difficulty = item.querySelector(".edit-difficulty").value;
        
        if (question && answer) {
            const originalCard = flashcards[index] || {};
            editedCards.push({
                ...originalCard,
                question,
                answer,
                tags,
                difficulty,
                updatedAt: new Date().toISOString()
            });
        }
    });
    
    if (editedCards.length > 0) {
        flashcards = editedCards;
        currentCardIndex = 0;
        shuffleFlashcards();
        resetCarousel();
        updateFlashcardCounter();
        updateStudyStats();
        loadAllTags();
        saveProgress();
        closeEditModal();
        alert("Deck updated successfully!");
    } else {
        alert("Cannot save empty deck!");
    }
}

function removeCardFromEditor(index) {
    if (confirm("Are you sure you want to remove this card?")) {
        document.querySelectorAll(".deck-editor-item")[index].remove();
    }
}

// Import/Export functions
function exportPreset() {
    if (flashcards.length === 0) {
        alert("No flashcards to export!");
        return;
    }
    
    const presetName = prompt("Enter a name for this export:");
    if (presetName) {
        const presetToExport = {
            name: presetName,
            cards: flashcards.map(card => ({
                question: card.question,
                answer: card.answer,
                tags: card.tags || [],
                difficulty: card.difficulty || 'normal',
                cardType: card.cardType || 'new'
            })),
            createdAt: new Date().toISOString(),
            version: "2.0"
        };
        
        const exportString = JSON.stringify(presetToExport, null, 2);
        
        navigator.clipboard.writeText(exportString)
            .then(() => alert(`Preset "${presetName}" copied to clipboard!`))
            .catch(err => {
                console.error("Export failed:", err);
                // Fallback: show in modal for manual copy
                showExportModal(exportString);
            });
    }
}

function showExportModal(exportString) {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content">
            <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
            <h2>Export Data</h2>
            <p>Copy the text below:</p>
            <textarea readonly style="width: 100%; height: 300px; font-family: monospace;">${exportString}</textarea>
        </div>
    `;
    document.body.appendChild(modal);
}

function importPreset() {
    navigator.clipboard.readText()
        .then(text => processImport(text))
        .catch(err => {
            // Fallback: show import modal
            showImportModal();
        });
}

function showImportModal() {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content">
            <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
            <h2>Import Preset</h2>
            <p>Paste your preset data below:</p>
            <textarea id="importTextArea" style="width: 100%; height: 200px; font-family: monospace;" placeholder="Paste preset data here..."></textarea>
            <button onclick="processImport(document.getElementById('importTextArea').value); this.closest('.modal').remove();">Import</button>
        </div>
    `;
    document.body.appendChild(modal);
}

function processImport(text) {
    try {
        const preset = JSON.parse(text);
        if (preset?.name && Array.isArray(preset.cards)) {
            if (confirm(`Import preset "${preset.name}" with ${preset.cards.length} cards?`)) {
                // Clean imported cards
                const cleanedCards = preset.cards.map(card => ({
                    question: card.question || '',
                    answer: card.answer || '',
                    tags: Array.isArray(card.tags) ? card.tags : [],
                    difficulty: card.difficulty || 'normal',
                    cardType: 'new',
                    confidence: 0,
                    easeFactor: card.easeFactor || 2.5,
                    repetitions: card.repetitions || 0,
                    interval: card.interval || 0,
                    createdAt: new Date().toISOString(),
                    ratingHistory: card.ratingHistory || []
                }));
                
                const presetToSave = {
                    ...preset,
                    cards: cleanedCards,
                    updatedAt: new Date().toISOString()
                };
                
                presets.push(presetToSave);
                localStorage.setItem("flashcardPresets", JSON.stringify(presets));
                updatePresetList();
                alert("Preset imported successfully!");
            }
        } else {
            throw new Error("Invalid format");
        }
    } catch (err) {
        alert("Invalid preset format. Please copy a valid preset.");
    }
}

// Bulk import functions
function showBulkImportModal() {
    document.getElementById("bulkTextInput").value = "";
    document.getElementById("bulkImportModal").style.display = "block";
    toggleDropdown();
}

function closeBulkImportModal() {
    document.getElementById("bulkImportModal").style.display = "none";
}

function processBulkImport() {
  const raw = document.getElementById('bulkTextInput').value;
  const lines = raw.split(/\r?\n/);

  const newFlashcards = [];
  let q = null;
  let options = [];
  let answerText = '';
  let answerLabel = null;

  const flush = () => {
    if (!q) return;
    // Resolve final answer
    let finalAnswer = answerText;
    if (!finalAnswer && answerLabel) {
      const match = options.find(o => o.label.toLowerCase() === answerLabel.toLowerCase());
      if (match) finalAnswer = `${match.label}) ${match.text}`;
    }
    newFlashcards.push({
      question: q,                 // keep question text only (options are separate)
      answer: finalAnswer || '',
      options,                     // [{label:'a', text:'...'}, …]
      correctOption: answerLabel || null,
      tags: [],
      difficulty: 'normal',
      cardType: 'new',
      confidence: 0,
      easeFactor: 2.5,
      repetitions: 0,
      interval: 0,
      createdAt: new Date().toISOString(),
      ratingHistory: []
    });
    q = null; options = []; answerText = ''; answerLabel = null;
  };

  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) continue;

    const qMatch = /^Q\d*:?\s*(.+)$/i.exec(line);
    if (qMatch) { flush(); q = qMatch[1]; continue; }

    if (q) {
      const optMatch = /^([a-d])[\)\.\:]\s*(.+)$/i.exec(line);
      if (optMatch) { options.push({ label: optMatch[1].toLowerCase(), text: optMatch[2] }); continue; }

      const aMatch = /^A\d*:?\s*(.+)$/i.exec(line);
      if (aMatch) {
        const txt = aMatch[1];
        const labelMatch = /^([a-d])[\)\.\:]/i.exec(txt);
        if (labelMatch) answerLabel = labelMatch[1].toLowerCase();
        answerText = txt;
        flush();
        continue;
      }
    }
  }
  // flush trailing question without A:
  flush();

  if (newFlashcards.length === 0) {
    alert('No cards found. Use Q1:/A1: and options like "a) foo"');
    return;
  }

  flashcards = [...flashcards, ...newFlashcards];
  shuffleFlashcards();
  resetCarousel();
  updateFlashcardCounter();
  updateStudyStats();
  loadAllTags();
  saveProgress();
  closeBulkImportModal();
  alert(`Imported ${newFlashcards.length} new flashcards!`);
}


function addDefaultFlashcards() {
    flashcards = [{
        question: "Welcome to Decked Out Enhanced!",
        answer: "This app now includes spaced repetition, statistics, tags, and more Anki-like features. Create or import flashcards to begin studying with advanced algorithms.",
        tags: ['welcome', 'tutorial'],
        difficulty: 'normal',
        cardType: 'new',
        confidence: 0,
        easeFactor: 2.5,
        repetitions: 0,
        interval: 0,
        createdAt: new Date().toISOString(),
        ratingHistory: []
    }];
    loadCard(document.querySelector(".main"), 0);
    loadAllTags();
    updateStudyStats();
}
let currentImageData = null;

function handleImageUpload(input) {
    if (input.files && input.files[0]) {
        const reader = new FileReader();
        
        reader.onload = function(e) {
            currentImageData = e.target.result;
            document.getElementById('previewImage').src = currentImageData;
            document.getElementById('imagePreview').style.display = 'block';
            document.querySelector('.remove-image').style.display = 'block';
        }
        
        reader.readAsDataURL(input.files[0]);
    }
}

function removeImage() {
    currentImageData = null;
    document.getElementById('imageUpload').value = '';
    document.getElementById('imagePreview').style.display = 'none';
    document.querySelector('.remove-image').style.display = 'none';
}

// Initialize app on page load
document.addEventListener("DOMContentLoaded", () => {
  loadProgress();
  init();

  // Cloze helpers
  const clozeTA = document.getElementById('clozeText');
  const wrapBtn = document.getElementById('clozeWrapBtn');
  const nextBtn = document.getElementById('clozeNextBtn');

  if (clozeTA) {
    clozeTA.addEventListener('input', updateClozePreview);
    // initialize preview if user reloads with content
    updateClozePreview();
  }
  if (wrapBtn) wrapBtn.addEventListener('click', wrapSelectionWithCloze);
  if (nextBtn) nextBtn.addEventListener('click', insertNextClozeAtCursor);
});

// Function to show again-rated cards
// Function to show again-rated cards
function showAgainCards() {
    const againCards = getAgainCards();
    const againCardsList = document.getElementById("againCardsList");
    
    if (againCards.length === 0) {
        againCardsList.innerHTML = "<p>No cards have been rated as 'Again' yet.</p>";
    } else {
        againCardsList.innerHTML = againCards.map(card => `
            <div class="again-card-item" style="padding: 15px; margin-bottom: 10px; background: var(--bg-secondary); border-radius: 8px;">
                <div style="font-weight: bold; margin-bottom: 5px;">${card.question}</div>
                <div style="margin-bottom: 10px;">${card.answer}</div>
                <div style="font-size: 12px; color: var(--text-dim);">
                    Tags: ${card.tags?.join(', ') || 'None'} | 
                    Ease Factor: ${card.easeFactor?.toFixed(2) || 'N/A'} | 
                    Repetitions: ${card.repetitions || 0} | 
                    Last Reviewed: ${formatDate(card.lastReviewed)} | 
                    Next Review: ${formatDate(card.nextReview)}
                </div>
                ${card.ratingHistory && card.ratingHistory.length > 0 ? 
                    `<div style="font-size: 11px; margin-top: 5px;">
                        Rating History: ${card.ratingHistory.map(r => r.rating).join(', ')}
                    </div>` : ''
                }
            </div>
        `).join('');
    }
    
    document.getElementById("againCardsModal").style.display = "block";
}

// Function to close the again cards modal
function closeAgainCardsModal() {
    document.getElementById("againCardsModal").style.display = "none";
}

// Helper function to get all again-rated cards
// Helper function to get all again-rated cards
function getAgainCards() {
    return flashcards.filter(card => {
        // Check if card has been rated as "Again" (rating 1) in its history
        if (card.ratingHistory && card.ratingHistory.length > 0) {
            const lastRating = card.ratingHistory[card.ratingHistory.length - 1].rating;
            return lastRating === 1;
        }
        
        // For backward compatibility, check ease factor for older cards
        return card.easeFactor < 1.8;
    });
}

// Helper function to format dates
function formatDate(dateString) {
    if (!dateString) return "Not scheduled";
    
    const date = new Date(dateString);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
}
// Function to migrate existing cards to new format
function migrateCards() {
    let needsMigration = false;
    
    flashcards.forEach(card => {
        if (card.easeFactor === undefined) {
            card.easeFactor = 2.5;
            needsMigration = true;
        }
        if (card.repetitions === undefined) {
            card.repetitions = 0;
            needsMigration = true;
        }
        if (card.interval === undefined) {
            card.interval = 0;
            needsMigration = true;
        }
        if (card.ratingHistory === undefined) {
            card.ratingHistory = [];
            needsMigration = true;
        }
    });
    
    if (needsMigration) {
        saveProgress();
    }
}
// Session Timer Functions
function showSessionTimerModal() {
    document.getElementById("sessionTimerModal").style.display = "block";
}

function closeSessionTimerModal() {
    document.getElementById("sessionTimerModal").style.display = "none";
}

function startTimedSession(minutes) {
    sessionActive = true;
    sessionType = 'timed';
    sessionEndTime = new Date(Date.now() + minutes * 60000);
    cardsReviewedInSession = 0;
    
    document.querySelector('.session-options').style.display = 'none';
    document.getElementById('sessionProgress').style.display = 'block';
    
    updateSessionTimer();
    sessionTimer = setInterval(updateSessionTimer, 1000);
    
    // Add to menu dropdown
    addToMenuDropdown();
}

function showCardLimitInput() {
    document.getElementById('cardLimitInput').style.display = 'block';
}

function startCardLimitSession() {
    const limit = parseInt(document.getElementById('cardLimit').value);
    if (isNaN(limit) || limit < 1) {
        alert('Please enter a valid number of cards');
        return;
    }
    
    sessionActive = true;
    sessionType = 'cardLimit';
    sessionCardLimit = limit;
    cardsReviewedInSession = 0;
    
    document.querySelector('.session-options').style.display = 'none';
    document.getElementById('cardLimitInput').style.display = 'none';
    document.getElementById('sessionProgress').style.display = 'block';
    
    document.getElementById('sessionTimer').textContent = `${cardsReviewedInSession}/${sessionCardLimit} cards`;
    
    // Add to menu dropdown
    addToMenuDropdown();
}

function updateSessionTimer() {
    if (sessionType === 'timed') {
        const now = new Date();
        const timeLeft = sessionEndTime - now;
        
        if (timeLeft <= 0) {
            endSession();
            return;
        }
        
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        
        document.getElementById('sessionTimer').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    } else if (sessionType === 'cardLimit') {
        document.getElementById('sessionTimer').textContent = 
            `${cardsReviewedInSession}/${sessionCardLimit} cards`;
    }
    
    document.getElementById('sessionCardsCompleted').textContent = 
        `${cardsReviewedInSession} cards reviewed`;
}

function trackCardReview() {
    if (sessionActive) {
        cardsReviewedInSession++;
        
        if (sessionType === 'cardLimit' && cardsReviewedInSession >= sessionCardLimit) {
            endSession();
            alert('Congratulations! You completed your card target!');
        } else {
            updateSessionTimer();
        }
    }
}

function endSession() {
    sessionActive = false;
    clearInterval(sessionTimer);
    
    document.getElementById("sessionTimerModal").style.display = "none";
    document.querySelector('.session-options').style.display = 'grid';
    document.getElementById('sessionProgress').style.display = 'none';
    document.getElementById('cardLimitInput').style.display = 'none';
    
    // Show session summary
    alert(`Session completed!\nYou reviewed ${cardsReviewedInSession} cards in this session.`);
    
    // Remove from menu dropdown
    removeFromMenuDropdown();
}

function addToMenuDropdown() {
    const menuItem = document.createElement('button');
    menuItem.id = 'sessionStatusMenuItem';
    menuItem.innerHTML = `<i class="fas fa-hourglass-half"></i> Session: ${sessionType === 'timed' ? document.getElementById('sessionTimer').textContent : `${cardsReviewedInSession}/${sessionCardLimit} cards`}`;
    menuItem.onclick = showSessionTimerModal;
    
    const dropdown = document.getElementById('presetDropdown');
    dropdown.insertBefore(menuItem, dropdown.firstChild);
}

function removeFromMenuDropdown() {
    const menuItem = document.getElementById('sessionStatusMenuItem');
    if (menuItem) {
        menuItem.remove();
    }
}
// Export Functions
function exportToCSV() {
    if (flashcards.length === 0) {
        alert("No flashcards to export!");
        return;
    }
    
    // Check if any cards have images
    const hasImages = flashcards.some(card => card.image);
    if (hasImages) {
        if (!confirm("Some flashcards contain images. Images cannot be exported to CSV format. Continue without images?")) {
            return;
        }
    }
    
    let csvContent = "Question,Answer,Tags,Difficulty\n";
    
    flashcards.forEach(card => {
        const question = `"${card.question.replace(/"/g, '""')}"`;
        const answer = `"${card.answer.replace(/"/g, '""')}"`;
        const tags = `"${(card.tags || []).join(',')}"`;
        const difficulty = `"${card.difficulty || 'normal'}"`;
        
        csvContent += `${question},${answer},${tags},${difficulty}\n`;
    });
    
    downloadFile(csvContent, 'flashcards.csv', 'text/csv');
}

function exportToAnki() {
    if (flashcards.length === 0) {
        alert("No flashcards to export!");
        return;
    }
    
    // Create a text file compatible with Anki's import format
    let ankiContent = "";
    
    flashcards.forEach(card => {
        const question = card.question.replace(/\t/g, ' ').replace(/\n/g, '<br>');
        const answer = card.answer.replace(/\t/g, ' ').replace(/\n/g, '<br>');
        const tags = (card.tags || []).join(' ');
        
        ankiContent += `${question}\t${answer}\t${tags}\n`;
    });
    
    downloadFile(ankiContent, 'anki_import.txt', 'text/plain');
}

function downloadFile(content, fileName, contentType) {
    const blob = new Blob([content], { type: contentType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, 0);
}
// Hardest Cards Review Mode
function startHardestCardsReview() {
    const hardestCards = getHardestCards();
    
    if (hardestCards.length === 0) {
        alert("No hardest cards found! Cards need to be rated 'Again' multiple times to appear here.");
        return;
    }
    
    // Initialize hardest cards session
    window.hardestCardsSession = {
        cards: hardestCards,
        currentIndex: 0,
        correct: 0,
        total: 0
    };
    
    // Show modal
    document.getElementById("hardestCardsModal").style.display = "block";
    
    // Load first card
    loadHardestCard(0);
    updateHardestCardsProgress();
}

function closeHardestCardsModal() {
    document.getElementById("hardestCardsModal").style.display = "none";
    delete window.hardestCardsSession;
}

function getHardestCards() {
    // Get cards rated "Again" at least twice or with low ease factor
    return flashcards.filter(card => {
        const againCount = card.ratingHistory ? 
            card.ratingHistory.filter(r => r.rating === 1).length : 0;
        
        return againCount >= 2 || (card.easeFactor && card.easeFactor < 1.5);
    });
}

function loadHardestCard(index) {
    const session = window.hardestCardsSession;
    if (!session || index >= session.cards.length) return;
    
    session.currentIndex = index;
    const card = session.cards[index];
    
    const carousel = document.getElementById("hardestCarousel");
    carousel.innerHTML = `
        <div class="flashcard main">
            <div class="card-metadata">
                <div class="card-tags">${(card.tags || []).map(t => `<span class="tag">${t}</span>`).join('')}</div>
                <div class="card-interval">Hardest</div>
            </div>
            <div class="card-face front">${card.question}</div>
            <div class="card-face back">${card.answer}</div>
        </div>
    `;
    
    // Add flip functionality
    carousel.querySelector('.flashcard').addEventListener('click', function() {
        this.classList.toggle('flipped');
    });
    
    // Update confidence buttons with specific intervals for hardest cards
    const buttonsContainer = document.getElementById("hardestConfidenceButtons");
    buttonsContainer.innerHTML = `
        <button class="confidence-btn again" onclick="rateHardestCard(1)">
            <div><i class="fas fa-times"></i> Again<div class="interval-time">10m</div></div>
        </button>
        <button class="confidence-btn hard" onclick="rateHardestCard(2)">
            <div><i class="fas fa-frown"></i> Hard<div class="interval-time">1h</div></div>
        </button>
        <button class="confidence-btn good" onclick="rateHardestCard(3)">
            <div><i class="fas fa-smile"></i> Good<div class="interval-time">6h</div></div>
        </button>
        <button class="confidence-btn easy" onclick="rateHardestCard(4)">
            <div><i class="fas fa-star"></i> Easy<div class="interval-time">1d</div></div>
        </button>
    `;
}

function rateHardestCard(rating) {
    const session = window.hardestCardsSession;
    if (!session) return;
    
    const card = session.cards[session.currentIndex];
    session.total++;
    
    // Track correct answers (ratings 3-4 are considered correct)
    if (rating >= 3) session.correct++;
    
    // Apply special intervals for hardest cards (shorter intervals)
    const now = new Date();
    let nextReview = new Date(now);
    
    switch(rating) {
        case 1: // Again - 10 minutes
            nextReview.setMinutes(now.getMinutes() + 10);
            break;
        case 2: // Hard - 1 hour
            nextReview.setHours(now.getHours() + 1);
            break;
        case 3: // Good - 6 hours
            nextReview.setHours(now.getHours() + 6);
            break;
        case 4: // Easy - 1 day
            nextReview.setDate(now.getDate() + 1);
            break;
    }
    
    // Update the actual card in the main deck
    const mainCardIndex = flashcards.findIndex(c => 
        c.question === card.question && c.answer === card.answer
    );
    
    if (mainCardIndex !== -1) {
        flashcards[mainCardIndex].nextReview = nextReview.toISOString();
        if (!flashcards[mainCardIndex].ratingHistory) {
            flashcards[mainCardIndex].ratingHistory = [];
        }
        flashcards[mainCardIndex].ratingHistory.push({
            rating: rating,
            date: now.toISOString(),
            fromHardestSession: true
        });
        
        // Adjust ease factor more aggressively for hardest cards
        if (rating === 1) {
            flashcards[mainCardIndex].easeFactor = Math.max(1.3, 
                (flashcards[mainCardIndex].easeFactor || 2.5) * 0.8);
        }
    }
    
    // Move to next card or end session
    if (session.currentIndex + 1 < session.cards.length) {
        loadHardestCard(session.currentIndex + 1);
    } else {
        alert(`Hardest cards session completed!\nScore: ${session.correct}/${session.total} (${Math.round(session.correct/session.total*100)}%)`);
        closeHardestCardsModal();
    }
    
    updateHardestCardsProgress();
    saveProgress();
}

function updateHardestCardsProgress() {
    const session = window.hardestCardsSession;
    if (!session) return;
    
    document.getElementById("hardestCardsProgress").textContent = 
        `${session.currentIndex + 1}/${session.cards.length} cards reviewed`;
    
    if (session.total > 0) {
        const percentage = Math.round((session.correct / session.total) * 100);
        document.getElementById("hardestCardsStats").textContent = `${percentage}% correct`;
    }
}

function endHardestCardsReview() {
    const session = window.hardestCardsSession;
    if (session) {
        alert(`Session ended. You reviewed ${session.currentIndex + 1} cards with ${session.correct} correct answers.`);
    }
    closeHardestCardsModal();
}
// Anki Import Functions
function showAnkiImportModal() {
    document.getElementById("ankiImportModal").style.display = "block";
    toggleDropdown();
}

function closeAnkiImportModal() {
    document.getElementById("ankiImportModal").style.display = "none";
}

function processAnkiFile() {
    const fileInput = document.getElementById("ankiFileUpload");
    if (!fileInput.files.length) {
        alert("Please select an Anki .apkg file");
        return;
    }
    
    alert("APKG file processing would require additional libraries. For now, please use the text export option.");
    // In a real implementation, you would use a library like https://github.com/eshah/anki-apkg-export
}

function processAnkiText() {
    const text = document.getElementById("ankiExportText").value.trim();
    if (!text) {
        alert("Please paste Anki export text");
        return;
    }
    
    try {
        const cards = parseAnkiText(text);
        showAnkiPreview(cards);
    } catch (e) {
        alert("Error parsing Anki text: " + e.message);
    }
}

function parseAnkiText(text) {
    // Parse tab-separated values (standard Anki export format)
    const lines = text.split('\n').filter(line => line.trim());
    const cards = [];
    
    for (const line of lines) {
        // Skip header line if present
        if (line.toLowerCase().includes('question') && line.toLowerCase().includes('answer')) {
            continue;
        }
        
        const parts = line.split('\t');
        if (parts.length >= 2) {
            const question = parts[0].trim();
            const answer = parts[1].trim();
            const tags = parts.length > 2 ? parts[2].split(' ').filter(t => t) : [];
            
            if (question && answer) {
                cards.push({
                    question: question,
                    answer: answer,
                    tags: tags,
                    difficulty: 'normal',
                    cardType: 'new',
                    confidence: 0,
                    easeFactor: 2.5,
                    repetitions: 0,
                    interval: 0,
                    createdAt: new Date().toISOString(),
                    ratingHistory: [],
                    source: 'anki_import'
                });
            }
        }
    }
    
    return cards;
}

function showAnkiPreview(cards) {
    const previewList = document.getElementById("ankiPreviewList");
    previewList.innerHTML = "";
    
    if (cards.length === 0) {
        previewList.innerHTML = "<p>No valid flashcards found in the import.</p>";
        return;
    }
    
    previewList.innerHTML = `<p>Found ${cards.length} cards:</p>`;
    
    cards.slice(0, 5).forEach((card, i) => {
        previewList.innerHTML += `
            <div class="preview-card">
                <strong>Q:</strong> ${card.question.substring(0, 100)}${card.question.length > 100 ? '...' : ''}<br>
                <strong>A:</strong> ${card.answer.substring(0, 100)}${card.answer.length > 100 ? '...' : ''}
            </div>
        `;
    });
    
    if (cards.length > 5) {
        previewList.innerHTML += `<p>...and ${cards.length - 5} more cards</p>`;
    }
    
    window.pendingAnkiImport = cards;
    document.getElementById("ankiPreview").style.display = "block";
}

function importAnkiCards() {
    if (!window.pendingAnkiImport || window.pendingAnkiImport.length === 0) {
        alert("No cards to import");
        return;
    }
    
    flashcards = [...flashcards, ...window.pendingAnkiImport];
    saveProgress();
    updateStudyStats();
    updateFlashcardCounter();
    loadAllTags();
    
    alert(`Successfully imported ${window.pendingAnkiImport.length} cards from Anki!`);
    closeAnkiImportModal();
    delete window.pendingAnkiImport;
}
function updateCardImage(input, index) {
    if (input.files && input.files[0]) {
        const reader = new FileReader();
        
        reader.onload = function(e) {
            flashcards[index].image = e.target.result;
            showEditModal(); // Refresh the editor to show the new image
        }
        
        reader.readAsDataURL(input.files[0]);
    }
}

function removeCardImage(index) {
    flashcards[index].image = null;
    showEditModal(); // Refresh the editor
}
// Search and Filter Functions
function initSearchFilter() {
    populateTagFilter();
    document.getElementById('searchInput').addEventListener('input', debounce(applyFilters, 300));
    document.getElementById('tagFilter').addEventListener('change', applyFilters);
    document.getElementById('difficultyFilter').addEventListener('change', applyFilters);
}

function populateTagFilter() {
    const tagFilter = document.getElementById('tagFilter');
    const currentTags = tagFilter.innerHTML;
    tagFilter.innerHTML = currentTags; // Keep the "All Tags" option
    
    allTags.forEach(tag => {
        if (!currentTags.includes(`value="${tag}"`)) {
            const option = document.createElement('option');
            option.value = tag;
            option.textContent = tag;
            tagFilter.appendChild(option);
        }
    });
}

function applyFilters() {
    const searchTerm = document.getElementById('searchInput').value.toLowerCase();
    const selectedTag = document.getElementById('tagFilter').value;
    const selectedDifficulty = document.getElementById('difficultyFilter').value;
    
    // Create a copy of all flashcards for filtering
    let filteredCards = [...flashcards];
    
    // Apply search filter
    if (searchTerm) {
        filteredCards = filteredCards.filter(card => 
            card.question.toLowerCase().includes(searchTerm) || 
            card.answer.toLowerCase().includes(searchTerm)
        );
    }
    
    // Apply tag filter
    if (selectedTag) {
        filteredCards = filteredCards.filter(card => 
            card.tags && card.tags.includes(selectedTag)
        );
    }
    
    // Apply difficulty filter
    if (selectedDifficulty) {
        filteredCards = filteredCards.filter(card => 
            card.difficulty === selectedDifficulty
        );
    }
    
    // Update the displayed cards
    displayFilteredCards(filteredCards);
}

function displayFilteredCards(filteredCards) {
    // Create a temporary array for display
    const originalCards = [...flashcards];
    flashcards = filteredCards;
    
    // Update UI
    currentCardIndex = 0;
    resetCarousel();
    updateFlashcardCounter();
    
    // Show filter info
    const resultsInfo = document.createElement('div');
    resultsInfo.className = 'search-results-info';
    resultsInfo.innerHTML = `Showing ${filteredCards.length} of ${originalCards.length} cards 
        <button onclick="clearFilters()" style="margin-left: 10px; padding: 2px 8px; font-size: 12px;">Show All</button>`;
    
    // Remove existing info if any
    const existingInfo = document.querySelector('.search-results-info');
    if (existingInfo) existingInfo.remove();
    
    // Add new info
    document.querySelector('.app-container').insertBefore(resultsInfo, document.querySelector('.carousel'));
    
    // Restore original cards array for future filtering
    flashcards = originalCards;
}

function clearFilters() {
    document.getElementById('searchInput').value = '';
    document.getElementById('tagFilter').value = '';
    document.getElementById('difficultyFilter').value = '';
    
    // Remove results info
    const resultsInfo = document.querySelector('.search-results-info');
    if (resultsInfo) resultsInfo.remove();
    
    // Reset to show all cards
    currentCardIndex = 0;
    resetCarousel();
    updateFlashcardCounter();
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}
// Deck Management System
let decks = JSON.parse(localStorage.getItem("flashcardDecks")) || [];
let currentDeckId = null;
let creatingItemType = null; // 'deck' or 'folder'

function initDeckManager() {
    // If no decks exist, create a default deck
    if (decks.length === 0) {
        const defaultDeck = {
            id: generateId(),
            name: "Default Deck",
            type: "deck",
            cards: [...flashcards],
            parentId: null,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        decks.push(defaultDeck);
        currentDeckId = defaultDeck.id;
        saveDecks();
    } else {
        // Load the first deck by default
        currentDeckId = decks[0].id;
        loadDeck(currentDeckId);
    }
}

function showDeckManager() {
    renderDecksList();
    document.getElementById("deckManagerModal").style.display = "block";
}

function closeDeckManager() {
    document.getElementById("deckManagerModal").style.display = "none";
}

function renderDecksList(parentId = null) {
    const decksList = document.getElementById("decksList");
    decksList.innerHTML = "";
    
    const items = decks.filter(item => item.parentId === parentId);
    
    if (items.length === 0 && parentId === null) {
        decksList.innerHTML = `<p style="text-align: center; color: var(--text-dim);">No decks yet. Create your first deck!</p>`;
        return;
    }
    
    items.forEach(item => {
        const itemElement = document.createElement("div");
        itemElement.className = item.type === "folder" ? "folder-item" : "deck-item";
        
        if (item.type === "folder") {
            const childItems = decks.filter(i => i.parentId === item.id);
            const isCollapsed = item.collapsed || false;
            
            itemElement.innerHTML = `
                <div>
                    <span class="collapse-toggle" onclick="toggleFolder('${item.id}')">
                        <i class="fas fa-${isCollapsed ? 'chevron-right' : 'chevron-down'}"></i>
                    </span>
                    <i class="fas fa-folder"></i> ${item.name}
                </div>
                <div class="deck-actions">
                    <button onclick="event.stopPropagation(); editItem('${item.id}')">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button onclick="event.stopPropagation(); deleteItem('${item.id}')">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            decksList.appendChild(itemElement);
            
            // Add folder contents if not collapsed
            if (!isCollapsed && childItems.length > 0) {
                const contentsDiv = document.createElement("div");
                contentsDiv.className = "folder-contents";
                contentsDiv.id = `folder-${item.id}-contents`;
                decksList.appendChild(contentsDiv);
                renderDecksList(item.id, contentsDiv);
            }
        } else {
            // It's a deck
            const cardCount = item.cards ? item.cards.length : 0;
            const isCurrent = currentDeckId === item.id;
            
            itemElement.innerHTML = `
                <div class="deck-info">
                    <div class="deck-name">${item.name} ${isCurrent ? '(Current)' : ''}</div>
                    <div class="deck-meta">${cardCount} cards</div>
                </div>
                <div class="deck-actions">
                    <button onclick="event.stopPropagation(); loadDeck('${item.id}')">
                        <i class="fas fa-play"></i>
                    </button>
                    <button onclick="event.stopPropagation(); editItem('${item.id}')">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button onclick="event.stopPropagation(); deleteItem('${item.id}')">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            itemElement.onclick = () => loadDeck(item.id);
            decksList.appendChild(itemElement);
        }
    });
}

function createNewDeck() {
    creatingItemType = "deck";
    document.getElementById("createItemTitle").textContent = "Create New Deck";
    document.getElementById("itemName").value = "";
    document.getElementById("parentFolder").style.display = "block";
    populateParentFolderOptions();
    document.getElementById("createItemModal").style.display = "block";
}

function createNewFolder() {
    creatingItemType = "folder";
    document.getElementById("createItemTitle").textContent = "Create New Folder";
    document.getElementById("itemName").value = "";
    document.getElementById("parentFolder").style.display = "block";
    populateParentFolderOptions();
    document.getElementById("createItemModal").style.display = "block";
}

function populateParentFolderOptions() {
    const parentSelect = document.getElementById("parentFolder");
    parentSelect.innerHTML = '<option value="">Root Level</option>';
    
    const folders = decks.filter(item => item.type === "folder");
    folders.forEach(folder => {
        const option = document.createElement("option");
        option.value = folder.id;
        option.textContent = folder.name;
        parentSelect.appendChild(option);
    });
}

function closeCreateItemModal() {
    document.getElementById("createItemModal").style.display = "none";
}

document.getElementById("createItemForm").addEventListener("submit", function(e) {
    e.preventDefault();
    
    const name = document.getElementById("itemName").value.trim();
    const parentId = document.getElementById("parentFolder").value || null;
    
    if (!name) return;
    
    if (creatingItemType === "deck") {
        const newDeck = {
            id: generateId(),
            name: name,
            type: "deck",
            cards: [],
            parentId: parentId,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        decks.push(newDeck);
    } else {
        const newFolder = {
            id: generateId(),
            name: name,
            type: "folder",
            parentId: parentId,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            collapsed: false
        };
        decks.push(newFolder);
    }
    
    saveDecks();
    renderDecksList();
    closeCreateItemModal();
});

function loadDeck(deckId) {
    const deck = decks.find(d => d.id === deckId);
    if (!deck || deck.type !== "deck") return;
    
    currentDeckId = deckId;
    flashcards = deck.cards || [];
    currentCardIndex = 0;
    
    shuffleFlashcards();
    resetCarousel();
    updateStudyStats();
    updateFlashcardCounter();
    loadAllTags();
    
    closeDeckManager();
}

function editItem(itemId) {
    const item = decks.find(d => d.id === itemId);
    if (!item) return;
    
    const newName = prompt("Enter new name:", item.name);
    if (newName && newName.trim()) {
        item.name = newName.trim();
        item.updatedAt = new Date().toISOString();
        saveDecks();
        renderDecksList();
    }
}

function deleteItem(itemId) {
    const item = decks.find(d => d.id === itemId);
    if (!item) return;
    
    // Check if it's a folder with contents
    if (item.type === "folder") {
        const childItems = decks.filter(d => d.parentId === itemId);
        if (childItems.length > 0) {
            if (!confirm("This folder contains items. Delete everything inside as well?")) {
                return;
            }
            // Delete all child items
            decks = decks.filter(d => d.parentId !== itemId);
        }
    }
    
    if (confirm(`Are you sure you want to delete "${item.name}"?`)) {
        // Don't delete the current deck if it's the only one
        if (item.type === "deck" && decks.filter(d => d.type === "deck").length <= 1) {
            alert("You need to have at least one deck.");
            return;
        }
        
        decks = decks.filter(d => d.id !== itemId);
        saveDecks();
        renderDecksList();
        
        // If we deleted the current deck, load the first available deck
        if (itemId === currentDeckId) {
            const firstDeck = decks.find(d => d.type === "deck");
            if (firstDeck) {
                loadDeck(firstDeck.id);
            }
        }
    }
}

function toggleFolder(folderId) {
    const folder = decks.find(d => d.id === folderId && d.type === "folder");
    if (folder) {
        folder.collapsed = !folder.collapsed;
        saveDecks();
        renderDecksList();
    }
}

function saveDecks() {
    // Also save the current deck's cards
    const currentDeck = decks.find(d => d.id === currentDeckId);
    if (currentDeck) {
        currentDeck.cards = [...flashcards];
        currentDeck.updatedAt = new Date().toISOString();
    }
    
    localStorage.setItem("flashcardDecks", JSON.stringify(decks));
}

function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}
// Auto-save progress every 30 seconds
setInterval(saveProgress, 30000);

// Save progress before page unload
window.addEventListener('beforeunload', saveProgress);
    </script>
</body>
</html>
